{"type":"system","subtype":"init","cwd":"/home/runner/work/slang/slang","session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281","tools":["Task","Bash","Glob","Grep","LS","exit_plan_mode","Read","Edit","MultiEdit","Write","NotebookRead","NotebookEdit","TodoWrite","mcp__github_comment__update_claude_comment","mcp__deepwiki__read_wiki_structure","mcp__deepwiki__read_wiki_contents","mcp__deepwiki__ask_question"],"mcp_servers":[{"name":"github_comment","status":"connected"},{"name":"deepwiki","status":"connected"}],"model":"us.anthropic.claude-sonnet-4-20250514-v1:0","permissionMode":"default","apiKeySource":"none"}
{"type":"assistant","message":{"id":"msg_bdrk_011YfTcRHAuHkNBxsSfFy74H","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me analyze this GitHub issue and understand what I need to do:\n\n1. **Issue Context**: This is about renaming `Slang::Session` to `Slang::GlobalSession` to align with the public API naming\n2. **Task**: Create a PR that implements the renaming described in the issue\n3. **Current state**: I'm on branch `claude/issue-7793-20250716_205207`\n\nLet me break down the tasks from the issue:\n- [ ] Rename the class `Slang::Session` to `Slang::GlobalSession` and fix all references \n- [ ] Rename variables that refer to a `Slang::GlobalSession` but are simply named `session` to `globalSession`\n- [ ] Rename accessors that return a `Slang::GlobalSession*` but are simply named `getSession()` to `getGlobalSession()`\n\nThis is a large-scale refactoring task that will touch many files. I need to:\n1. First understand the current codebase structure\n2. Find all occurrences of `Slang::Session` \n3. Systematically rename them\n4. Make sure I don't break functionality\n5. Follow the repository's coding standards\n\nLet me start by creating the initial comment with my todo list.","signature":"EtIJCkgIBRABGAIqQLb/wlxZ4tw5IfqW4F/ytMDldtSXHHk8w/YRlIVVPk4hrvsstqQXjwgAiEuieqLmGGYyW8hGpxJir47vOPkPi9gSDAYvnCP8UQCzl3MGIhoMkOUN47+iaBbvGVEJIjA1d4eoeTEzswbjO068KOIJiv+0yjoxsHOXa/yCW5w/opS88L0ZHHIUaqLPEzDRsAQqtwh5s6ISS4Hxwx7N4FuR4aTs3iIOW+i0Qil+VWWCnzPzmpWhQy4Y3jzS6si7Qsa9pio/tMXb2BMsTcoG3+e5c7nDhKAOBjCFR2PgURpA9hV8q4ltEVx293M5J875QPUtqucdXFcedR8lo/KjFhtF2zpBjTHjSU0iDwNRzv7Hf45Xl/uvg6/zjUe/HL0TqxwZDzrxrvIxl5of90Uy19sldWOSFfTCvx3KRPx/7ufCG2wliPjJZONXbbuxKj2egl3Y2qW03wEij/1t3j0tX98vQlaD6qehgeVEHfN/JLruXYisgrcEbDT84skbvCFxvpzOcx1YdId6/3eBleHlCNjpN4+th6uayiwqjMKTgaEA/L5Ueggd/DQX/Yd3qUPRJZ1p3By1o+A3dyJEGEfyul9TDyXv7+BiXtOXh05lo7y5+zAO6B5ncTkPP/bgfkG41jVRxl6rdR5I34Z/noCURNNaEKuURuNJwSkOAEXSvrpBSnQw1XGUEDygPL4lt14Me3XF9bX+m/GOSRf1Cisc2PMKDYYNU4J7RJeJacyamvWlYclUr23AkmDuaAXCgqWfjS2wsIIaQbXZGxWyaw/3qvkKGZje6WsXWkhPeHJRihrTB/8zM52gh3kIrKLH5aCSRhQ/ad7YhgDcujYx/8V/z+E88MUrXPKuc2ZBck6O6qXNvt3wsB99OgXoPyhqTP5iU2YGpLMLm25OBkxeiothiD7ALengooL2eMYJuNLaXL9KbJvQCUFqtdGtwroU/cQFr1nc6Q+r2scZi9eIA+t6TacbbmsuvrLPrSfvjUk1yUaxShQmDPTTpR4H8jR2Dygp/UQf325G0mxNMFJNv36RMtZKbRtouaEsszw2tDWLuNFKCNEBehJlsQnkxcfxV5yhpi/QVlkMYxThEteI9h4buYHmK9xPnRRvmbBlZ1fwC/KPtLjNEY6uFE//Fs9zBnRTlEGGhsk/JqYaFwUr7uk5yVev54xnzu+MmXBsGelhZ8p7sFl2CJVgjcvKaU1DRwZlEwlxVAJcMNV08B2rilDPi3nUcENV1PxKQ4FA0dUklHwx6snXmBdsbciwB221Hk+rBy7oWK6aVj68po839FnJekoa6YKxwzP4r4rO4vaImCNkc3c7JgP7sD3c+EI7zycw20z7ub0fls/UragquQbwNW/WLNfpoiLzrRY3wUFuh11lRSsXwdwFuVhdTRKOt76XWNDc8PsiEAH2AVkfz23Y5lAfz10nL2B7jlUIO8KjuFmg7gu0t8YtoWCGrmLHRRp8PjjhoW7Jwnwh6R2B3WUKyDTpUEiNQYEEq9GBo7p1otMUIf8TrGbPVh0pNONOMCeItGqIwjeQ8MDELLH6QQIT9Y7Ni4p5sowjTxnTTspz3b/QFkFSdSqF68n405agD8fHlxLYFaeFVjo/PCCpFBo6YjeQiiVoTlMpMMHIwxgB"}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":21129,"cache_read_input_tokens":0,"output_tokens":1116}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_011YfTcRHAuHkNBxsSfFy74H","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"<analysis>\na. **Event Type and Context**: This is a GENERAL_COMMENT event on an open GitHub issue. The user @tangent-vector is requesting me to create a PR that implements the renaming described in issue #7793.\n\nb. **Request Type**: This is an implementation request for a large-scale refactoring task to rename `Slang::Session` to `Slang::GlobalSession` throughout the codebase.\n\nc. **Key Information**:\n   - Issue involves renaming internal class names to align with public API\n   - Need to rename `Slang::Session` → `Slang::GlobalSession`\n   - Need to rename variables from `session` → `globalSession` \n   - Need to rename accessors from `getSession()` → `getGlobalSession()`\n   - This is a large refactoring that will touch many files\n   - Should only focus on renaming, no functionality changes\n   - I'm already on the correct branch: `claude/issue-7793-20250716_205207`\n\nd. **Main Tasks and Challenges**:\n   - Find all occurrences of `Slang::Session` class and rename to `Slang::GlobalSession`\n   - Find all variable names that should be renamed for clarity\n   - Find all method names that should be renamed for clarity  \n   - Ensure all comments and documentation are updated\n   - This will be a large-scale change touching many files\n   - Need to be careful not to break functionality\n   - Need to follow repository coding standards\n\ne. **High-level Plan**:\n   1. Use search tools to understand current codebase structure\n   2. Find all occurrences of `Slang::Session` class definition and references\n   3. Systematically rename class, variables, and methods\n   4. Test that the build still works\n   5. Run formatting script before committing\n   6. Commit and push changes\n   7. Create PR link\n\nf. **Potential Limitations**: I may not be able to run the full test suite depending on system requirements, but I can at least verify the build compiles.\n</analysis>"}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":21129,"cache_read_input_tokens":0,"output_tokens":1116}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_011YfTcRHAuHkNBxsSfFy74H","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_0142rWW4Bznhu5LtaWMSnxDy","name":"mcp__github_comment__update_claude_comment","input":{"body":"Working on implementing the `Slang::Session` → `Slang::GlobalSession` renaming <img src=\"https://github.com/user-attachments/assets/5ac382c7-e004-429b-8e35-7feb3e8f9c6f\" width=\"14px\" height=\"14px\" style=\"vertical-align: middle; margin-left: 4px;\" />\n\n### Task List\n- [ ] Analyze codebase structure and find all `Slang::Session` references\n- [ ] Rename the class `Slang::Session` to `Slang::GlobalSession` in header files\n- [ ] Update all references to the class name in implementation files  \n- [ ] Rename variables from `session` to `globalSession` where appropriate\n- [ ] Rename accessor methods from `getSession()` to `getGlobalSession()` etc.\n- [ ] Update comments and documentation\n- [ ] Verify build still works\n- [ ] Run formatting script\n- [ ] Commit and push changes\n- [ ] Create PR link\n\n---\n[View job run](https://github.com/shader-slang/slang/actions/runs/16329805070)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":21129,"cache_read_input_tokens":0,"output_tokens":1116}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_0142rWW4Bznhu5LtaWMSnxDy","type":"tool_result","content":[{"type":"text","text":"{\n  \"id\": 3080606462,\n  \"html_url\": \"https://github.com/shader-slang/slang/issues/7793#issuecomment-3080606462\",\n  \"updated_at\": \"2025-07-16T20:53:35Z\"\n}"}]}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01VcexXpcujWawYX6xAikMck","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Now let me start with the first task - analyzing the codebase to understand the structure and find all `Slang::Session` references. I'll use the search tools to understand the scope of this refactoring.\n\nFirst, let me search for `Slang::Session` to see where the class is defined and used.","signature":"Es0DCkgIBRABGAIqQOkO82wK7v1wdFsW0gETQS1R5UKVDbdmLF76PfPunS69uL9jEfmrmjInboRW86uWgHIVwCMqf+p1qTlalf1cmV8SDAkDS9Qps9Jmi5ibBhoMFNwW9vdxddDS2ZmwIjD8JVOd45RJlwU4I8V5PuCksKPHxXs8eqACG/d2xaCgJbQfAipnIAUyLOhWT0ebjs8qsgJPjeSEDuNDSePPPJVCJ+cK184fH3c5lHVzXTbKqLu5uK1yHJBLFSDV9ep1ampP4KQYjFY+wSy4bk7Y0tovymxd23NBqe4LoS09iWZx37ipd7diEJc5aKch7Jfd/NMBTH7jGtY+rJRgdFTB8GyAvXBL5frcORdpUtwaNjE837w5NYAuVPljzbkiWB3sjSj65hq9xolH1jKHyF6kqACO0Z5EfofFrvvftazRyKC77ntBr+6A6l/UAkg3k4f29C0wUl3xWvfxMK7T3RlQlDkj8Uae5V2HDp1pOdhMlPoNoogFg8zzhgQnCGSfus4FvNm+KKVIsBDX1BIg5cO3TOZH3tGcRGcFyVzrUShEORtUGBhDocIny2YUriUg3Y7yJofoZmYUJI+kcU8IK/yVdtBVooJPSfYYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":23536,"cache_read_input_tokens":0,"output_tokens":2}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01VcexXpcujWawYX6xAikMck","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01KNGU6VQoSguPzYeocAqDVU","name":"Grep","input":{"pattern":"Slang::Session"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":23536,"cache_read_input_tokens":0,"output_tokens":135}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01KNGU6VQoSguPzYeocAqDVU","type":"tool_result","content":"Found 60 files\n/home/runner/work/slang/slang/external/slang-rhi/tests/test-precompiled-module-cache.cpp\n/home/runner/work/slang/slang/external/slang-rhi/tests/test-precompiled-module.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/slang-context.h\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-separate-debug.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-slang-vm.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-type-conformance.cpp\n/home/runner/work/slang/slang/tools/slangi/main.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-generic-interface-conformance.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-geometry-shader.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-get-target-code.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-glsl-compile.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-image-format-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-metal-parameter-block-constant-buffer.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-module-ptr.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-parameter-usage-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-ptr-layout.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-argument-buffer-tier-2-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-atomic-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-attribute-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-compile-benchmark.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-cuda-compile.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-decl-tree-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-default-matrix-layout.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-fcpw-compile.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-find-check-entrypoint.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-find-entrypoint-nested.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-function-reflection.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-generic-entrypoint.cpp\n/home/runner/work/slang/slang/tools/slang-test/slangi-tool-impl.h\n/home/runner/work/slang/slang/tools/render-test/slang-support.cpp\n/home/runner/work/slang/slang/tools/gfx/slang-context.h\n/home/runner/work/slang/slang/tools/gfx-unit-test/precompiled-module-2.cpp\n/home/runner/work/slang/slang/tools/gfx-unit-test/precompiled-module-cache.cpp\n/home/runner/work/slang/slang/tools/gfx-unit-test/precompiled-module.cpp\n/home/runner/work/slang/slang/source/slang/slang.cpp\n/home/runner/work/slang/slang/source/slang/slang-workspace-version.cpp\n/home/runner/work/slang/slang/source/slang/slang-options.cpp\n/home/runner/work/slang/slang/source/slang/slang-language-server.cpp\n/home/runner/work/slang/slang/source/slang/slang-emit.cpp\n/home/runner/work/slang/slang/source/slang/slang-compiler.h\n/home/runner/work/slang/slang/source/slang/slang-api.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/replay/json-consumer.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/replay/json-consumer.h\n/home/runner/work/slang/slang/source/slang-record-replay/replay/parameter-decoder.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/replay/parameter-decoder.h\n/home/runner/work/slang/slang/source/slang-record-replay/replay/replay-consumer.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/replay/replay-consumer.h\n/home/runner/work/slang/slang/source/slang-record-replay/replay/slang-decoder.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/util/emum-to-string.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-global-session.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-global-session.h\n/home/runner/work/slang/slang/source/slang-record-replay/replay/decoder-consumer.h\n/home/runner/work/slang/slang/source/slang-record-replay/replay/decoder-helper.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/record/parameter-recorder.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/record/parameter-recorder.h\n/home/runner/work/slang/slang/examples/reflection-api/main.cpp\n/home/runner/work/slang/slang/examples/hello-world/main.cpp\n/home/runner/work/slang/slang/examples/cpu-hello-world/main.cpp\n/home/runner/work/slang/slang/docs/user-guide/a2-01-spirv-target-specific.md\n/home/runner/work/slang/slang/docs/user-guide/a1-01-matrix-layout.md"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_013ynYpgEjhkbykym9Sfg7u4","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Great! I found 60 files that contain `Slang::Session`. This is quite a lot, so this is indeed a large-scale refactoring. Now let me find the actual class definition to understand the structure better.","signature":"EvQCCkgIBRABGAIqQOoM9/oUMZg8VrF6fq7dqHS0Ig9fXwLaOjMyQly3U9Eerj04tk2JTSnyH0mcLkDJYcxiemZQ/MNBIu+n02ltS7ESDMyx1Imn5vJUlg8UiRoMac90UXcC4e5hypmpIjCw0FqI4oRHpJcp4Z/1o+hUkWcicS8sWs6tG/d3tPCWiVpsNKZyRzQvIHbenit1+8gq2QHabRFvxoqM/Om3C1w+x5Yg0vhyFk8cYujq1GDO/okI0Pgez4wI77ug1GInYs6U5eyR4I0SQjYxbiu4ciIzQEYp1hRT8DHH0X2dgfDQPoabTpOk5Pj9Zmr1Lp/dU1j9Wt+jfZfaAA2x6nduO25QQgaW8S7xSEoq7XDbllZJaAsb9eGwXNXruHgotK/3hPjRqxjDVfBVEJoUSewzM6Rk+vtCmOGYEfL+rIDcbiHr6PJSwAt6wQ1YSYa6N2yprxY7RrGdxfg+AMu8FgdFggRXRBfXMM8OR2o3Z1qfGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":4415,"cache_read_input_tokens":21129,"output_tokens":4}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_013ynYpgEjhkbykym9Sfg7u4","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01DiNsm3SCXR9fAh7TQRoty6","name":"Grep","input":{"pattern":"class Session","include":"*.h"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":4415,"cache_read_input_tokens":21129,"output_tokens":129}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01DiNsm3SCXR9fAh7TQRoty6","type":"tool_result","content":"Found 17 files\n/home/runner/work/slang/slang/source/slang/slang-serialize-ir.h\n/home/runner/work/slang/slang/source/slang/slang-ir.h\n/home/runner/work/slang/slang/source/slang/slang-ir-synthesize-active-mask.h\n/home/runner/work/slang/slang/source/slang/slang-ir-glsl-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-ir-hlsl-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-ir-byte-address-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-compiler-options.h\n/home/runner/work/slang/slang/source/slang/slang-compiler.h\n/home/runner/work/slang/slang/source/slang/slang-ast-support-types.h\n/home/runner/work/slang/slang/source/slang/slang-artifact-output-util.h\n/home/runner/work/slang/slang/source/slang-wasm/slang-wasm.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-composite-component-type.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-entrypoint.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-module.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-session.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-type-conformance.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-component-type.h"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01LTM9J8wKv3ksGPVRQZ5XB9","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"I found several files that have \"class Session\". Now let me look specifically in the main compiler header file to find the actual `Slang::Session` class definition:","signature":"EtECCkgIBRABGAIqQPDbCjOUlMtCo0y1TDYd+DtGK9GO/FzsUfmajx+0Us5WBiZRWz23H9hpKQ4eosgX3lmNWo4RJ0i+DJG4vv8x2IkSDPoIQRl8pDdelGzLvRoMfEj+aRhTGWi64JIAIjAl2HlYJFYFuiUYyxStIB0ioG3ZnbfKq6PJFJ+cZORyXnU+Ncb6OiH4/L5Ts2co/ZgqtgFBpezQgDBmSIWM5z6Qtf5Lqe3XlwuVIxJWoERJmsHIzhr9NgGtP2C8A4kXrWILf3LsdlemzBSobUobUs1+6F5MJw0IqEfZGsRvtly6ZLVrTFvvwuGFzWwC8dHBUzLklU74TOM16SAkajLUHXqzxKUHZFtoegDhoORTZOY3CfHXiUOXbAPhdfVsp8yUVURxsSK30WPY3+h4tPqHVQHUss5xPpSK+qtDrLPa6wGYdgqI76ZfNGzl6RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":666,"cache_read_input_tokens":25544,"output_tokens":7}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01LTM9J8wKv3ksGPVRQZ5XB9","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01DGw5iwScFYuXNNfyDKQQdN","name":"Read","input":{"file_path":"/home/runner/work/slang/slang/source/slang/slang-compiler.h"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":666,"cache_read_input_tokens":25544,"output_tokens":120}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01DGw5iwScFYuXNNfyDKQQdN","type":"tool_result","content":"     1→#ifndef SLANG_COMPILER_H_INCLUDED\n     2→#define SLANG_COMPILER_H_INCLUDED\n     3→\n     4→#include \"../compiler-core/slang-artifact-representation-impl.h\"\n     5→#include \"../compiler-core/slang-command-line-args.h\"\n     6→#include \"../compiler-core/slang-downstream-compiler-util.h\"\n     7→#include \"../compiler-core/slang-downstream-compiler.h\"\n     8→#include \"../compiler-core/slang-include-system.h\"\n     9→#include \"../compiler-core/slang-name.h\"\n    10→#include \"../compiler-core/slang-source-embed-util.h\"\n    11→#include \"../compiler-core/slang-spirv-core-grammar.h\"\n    12→#include \"../core/slang-basic.h\"\n    13→#include \"../core/slang-command-options.h\"\n    14→#include \"../core/slang-crypto.h\"\n    15→#include \"../core/slang-file-system.h\"\n    16→#include \"../core/slang-shared-library.h\"\n    17→#include \"../core/slang-std-writers.h\"\n    18→#include \"slang-capability.h\"\n    19→#include \"slang-com-ptr.h\"\n    20→#include \"slang-compiler-options.h\"\n    21→#include \"slang-content-assist-info.h\"\n    22→#include \"slang-diagnostics.h\"\n    23→#include \"slang-hlsl-to-vulkan-layout-options.h\"\n    24→#include \"slang-preprocessor.h\"\n    25→#include \"slang-profile.h\"\n    26→#include \"slang-serialize-ir-types.h\"\n    27→#include \"slang-syntax.h\"\n    28→#include \"slang.h\"\n    29→\n    30→#include <chrono>\n    31→\n    32→namespace Slang\n    33→{\n    34→struct PathInfo;\n    35→struct IncludeHandler;\n    36→struct SharedSemanticsContext;\n    37→struct ModuleChunk;\n    38→\n    39→class ProgramLayout;\n    40→class PtrType;\n    41→class TargetProgram;\n    42→class TargetRequest;\n    43→class TypeLayout;\n    44→class Artifact;\n    45→\n    46→enum class CompilerMode\n    47→{\n    48→    ProduceLibrary,\n    49→    ProduceShader,\n    50→    GenerateChoice\n    51→};\n    52→\n    53→enum class StageTarget\n    54→{\n    55→    Unknown,\n    56→    VertexShader,\n    57→    HullShader,\n    58→    DomainShader,\n    59→    GeometryShader,\n    60→    FragmentShader,\n    61→    ComputeShader,\n    62→};\n    63→\n    64→enum class CodeGenTarget : SlangCompileTargetIntegral\n    65→{\n    66→    Unknown = SLANG_TARGET_UNKNOWN,\n    67→    None = SLANG_TARGET_NONE,\n    68→    GLSL = SLANG_GLSL,\n    69→    HLSL = SLANG_HLSL,\n    70→    SPIRV = SLANG_SPIRV,\n    71→    SPIRVAssembly = SLANG_SPIRV_ASM,\n    72→    DXBytecode = SLANG_DXBC,\n    73→    DXBytecodeAssembly = SLANG_DXBC_ASM,\n    74→    DXIL = SLANG_DXIL,\n    75→    DXILAssembly = SLANG_DXIL_ASM,\n    76→    CSource = SLANG_C_SOURCE,\n    77→    CPPSource = SLANG_CPP_SOURCE,\n    78→    PyTorchCppBinding = SLANG_CPP_PYTORCH_BINDING,\n    79→    HostCPPSource = SLANG_HOST_CPP_SOURCE,\n    80→    HostExecutable = SLANG_HOST_EXECUTABLE,\n    81→    HostSharedLibrary = SLANG_HOST_SHARED_LIBRARY,\n    82→    ShaderSharedLibrary = SLANG_SHADER_SHARED_LIBRARY,\n    83→    ShaderHostCallable = SLANG_SHADER_HOST_CALLABLE,\n    84→    CUDASource = SLANG_CUDA_SOURCE,\n    85→    PTX = SLANG_PTX,\n    86→    CUDAObjectCode = SLANG_CUDA_OBJECT_CODE,\n    87→    ObjectCode = SLANG_OBJECT_CODE,\n    88→    HostHostCallable = SLANG_HOST_HOST_CALLABLE,\n    89→    Metal = SLANG_METAL,\n    90→    MetalLib = SLANG_METAL_LIB,\n    91→    MetalLibAssembly = SLANG_METAL_LIB_ASM,\n    92→    WGSL = SLANG_WGSL,\n    93→    WGSLSPIRVAssembly = SLANG_WGSL_SPIRV_ASM,\n    94→    WGSLSPIRV = SLANG_WGSL_SPIRV,\n    95→    HostVM = SLANG_HOST_VM,\n    96→    CountOf = SLANG_TARGET_COUNT_OF,\n    97→};\n    98→\n    99→bool isHeterogeneousTarget(CodeGenTarget target);\n   100→\n   101→void printDiagnosticArg(StringBuilder& sb, CodeGenTarget val);\n   102→\n   103→enum class ContainerFormat : SlangContainerFormatIntegral\n   104→{\n   105→    None = SLANG_CONTAINER_FORMAT_NONE,\n   106→    SlangModule = SLANG_CONTAINER_FORMAT_SLANG_MODULE,\n   107→};\n   108→\n   109→enum class LineDirectiveMode : SlangLineDirectiveModeIntegral\n   110→{\n   111→    Default = SLANG_LINE_DIRECTIVE_MODE_DEFAULT,\n   112→    None = SLANG_LINE_DIRECTIVE_MODE_NONE,\n   113→    Standard = SLANG_LINE_DIRECTIVE_MODE_STANDARD,\n   114→    GLSL = SLANG_LINE_DIRECTIVE_MODE_GLSL,\n   115→    SourceMap = SLANG_LINE_DIRECTIVE_MODE_SOURCE_MAP,\n   116→};\n   117→\n   118→enum class ResultFormat\n   119→{\n   120→    None,\n   121→    Text,\n   122→    Binary,\n   123→};\n   124→\n   125→// When storing the layout for a matrix-type\n   126→// value, we need to know whether it has been\n   127→// laid out with row-major or column-major\n   128→// storage.\n   129→//\n   130→enum MatrixLayoutMode : SlangMatrixLayoutModeIntegral\n   131→{\n   132→    kMatrixLayoutMode_RowMajor = SLANG_MATRIX_LAYOUT_ROW_MAJOR,\n   133→    kMatrixLayoutMode_ColumnMajor = SLANG_MATRIX_LAYOUT_COLUMN_MAJOR,\n   134→};\n   135→\n   136→enum class DebugInfoLevel : SlangDebugInfoLevelIntegral\n   137→{\n   138→    None = SLANG_DEBUG_INFO_LEVEL_NONE,\n   139→    Minimal = SLANG_DEBUG_INFO_LEVEL_MINIMAL,\n   140→    Standard = SLANG_DEBUG_INFO_LEVEL_STANDARD,\n   141→    Maximal = SLANG_DEBUG_INFO_LEVEL_MAXIMAL,\n   142→};\n   143→\n   144→enum class DebugInfoFormat : SlangDebugInfoFormatIntegral\n   145→{\n   146→    Default = SLANG_DEBUG_INFO_FORMAT_DEFAULT,\n   147→    C7 = SLANG_DEBUG_INFO_FORMAT_C7,\n   148→    Pdb = SLANG_DEBUG_INFO_FORMAT_PDB,\n   149→\n   150→    Stabs = SLANG_DEBUG_INFO_FORMAT_STABS,\n   151→    Coff = SLANG_DEBUG_INFO_FORMAT_COFF,\n   152→    Dwarf = SLANG_DEBUG_INFO_FORMAT_DWARF,\n   153→\n   154→    CountOf = SLANG_DEBUG_INFO_FORMAT_COUNT_OF,\n   155→};\n   156→\n   157→enum class OptimizationLevel : SlangOptimizationLevelIntegral\n   158→{\n   159→    None = SLANG_OPTIMIZATION_LEVEL_NONE,\n   160→    Default = SLANG_OPTIMIZATION_LEVEL_DEFAULT,\n   161→    High = SLANG_OPTIMIZATION_LEVEL_HIGH,\n   162→    Maximal = SLANG_OPTIMIZATION_LEVEL_MAXIMAL,\n   163→};\n   164→\n   165→struct CodeGenContext;\n   166→class EndToEndCompileRequest;\n   167→class FrontEndCompileRequest;\n   168→class Linkage;\n   169→class Module;\n   170→class TranslationUnitRequest;\n   171→\n   172→/// Information collected about global or entry-point shader parameters\n   173→struct ShaderParamInfo\n   174→{\n   175→    DeclRef<VarDeclBase> paramDeclRef;\n   176→    Int firstSpecializationParamIndex = 0;\n   177→    Int specializationParamCount = 0;\n   178→};\n   179→\n   180→/// A request for the front-end to find and validate an entry-point function\n   181→struct FrontEndEntryPointRequest : RefObject\n   182→{\n   183→public:\n   184→    /// Create a request for an entry point.\n   185→    FrontEndEntryPointRequest(\n   186→        FrontEndCompileRequest* compileRequest,\n   187→        int translationUnitIndex,\n   188→        Name* name,\n   189→        Profile profile);\n   190→\n   191→    /// Get the parent front-end compile request.\n   192→    FrontEndCompileRequest* getCompileRequest() { return m_compileRequest; }\n   193→\n   194→    /// Get the translation unit that contains the entry point.\n   195→    TranslationUnitRequest* getTranslationUnit();\n   196→\n   197→    /// Get the name of the entry point to find.\n   198→    Name* getName() { return m_name; }\n   199→\n   200→    /// Get the stage that the entry point is to be compiled for\n   201→    Stage getStage() { return m_profile.getStage(); }\n   202→\n   203→    /// Get the profile that the entry point is to be compiled for\n   204→    Profile getProfile() { return m_profile; }\n   205→\n   206→    /// Get the index to the translation unit\n   207→    int getTranslationUnitIndex() const { return m_translationUnitIndex; }\n   208→\n   209→private:\n   210→    // The parent compile request\n   211→    FrontEndCompileRequest* m_compileRequest;\n   212→\n   213→    // The index of the translation unit that will hold the entry point\n   214→    int m_translationUnitIndex;\n   215→\n   216→    // The name of the entry point function to look for\n   217→    Name* m_name;\n   218→\n   219→    // The profile to compile for (including stage)\n   220→    Profile m_profile;\n   221→};\n   222→\n   223→/// Tracks an ordered list of modules that something depends on.\n   224→/// TODO: Shader caching currently relies on this being in well defined order.\n   225→struct ModuleDependencyList\n   226→{\n   227→public:\n   228→    /// Get the list of modules that are depended on.\n   229→    List<Module*> const& getModuleList() { return m_moduleList; }\n   230→\n   231→    /// Add a module and everything it depends on to the list.\n   232→    void addDependency(Module* module);\n   233→\n   234→    /// Add a module to the list, but not the modules it depends on.\n   235→    void addLeafDependency(Module* module);\n   236→\n   237→private:\n   238→    void _addDependency(Module* module);\n   239→\n   240→    List<Module*> m_moduleList;\n   241→    HashSet<Module*> m_moduleSet;\n   242→};\n   243→\n   244→/// Tracks an unordered list of source files that something depends on\n   245→/// TODO: Shader caching currently relies on this being in well defined order.\n   246→struct FileDependencyList\n   247→{\n   248→public:\n   249→    /// Get the list of files that are depended on.\n   250→    List<SourceFile*> const& getFileList() { return m_fileList; }\n   251→\n   252→    /// Add a file to the list, if it is not already present\n   253→    void addDependency(SourceFile* sourceFile);\n   254→\n   255→    /// Add all of the paths that `module` depends on to the list\n   256→    void addDependency(Module* module);\n   257→\n   258→    void clear()\n   259→    {\n   260→        m_fileList.clear();\n   261→        m_fileSet.clear();\n   262→    }\n   263→\n   264→private:\n   265→    // TODO: We are using a `HashSet` here to deduplicate\n   266→    // the paths so that we don't return the same path\n   267→    // multiple times from `getFilePathList`, but because\n   268→    // order isn't important, we could potentially do better\n   269→    // in terms of memory (at some cost in performance) by\n   270→    // just sorting the `m_fileList` every once in\n   271→    // a while and then deduplicating.\n   272→\n   273→    List<SourceFile*> m_fileList;\n   274→    HashSet<SourceFile*> m_fileSet;\n   275→};\n   276→\n   277→\n   278→class EntryPoint;\n   279→\n   280→class ComponentType;\n   281→class ComponentTypeVisitor;\n   282→\n   283→/// Base class for \"component types\" that represent the pieces a final\n   284→/// shader program gets linked together from.\n   285→///\n   286→class ComponentType : public RefObject,\n   287→                      public slang::IComponentType,\n   288→                      public slang::IComponentType2,\n   289→                      public slang::IModulePrecompileService_Experimental\n   290→{\n   291→public:\n   292→    //\n   293→    // ISlangUnknown interface\n   294→    //\n   295→\n   296→    SLANG_REF_OBJECT_IUNKNOWN_ALL;\n   297→    ISlangUnknown* getInterface(Guid const& guid);\n   298→\n   299→    //\n   300→    // slang::IComponentType interface\n   301→    //\n   302→\n   303→    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE;\n   304→    SLANG_NO_THROW slang::ProgramLayout* SLANG_MCALL\n   305→    getLayout(SlangInt targetIndex, slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   306→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n   307→        SlangInt entryPointIndex,\n   308→        SlangInt targetIndex,\n   309→        slang::IBlob** outCode,\n   310→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   311→\n   312→    IArtifact* getTargetArtifact(SlangInt targetIndex, slang::IBlob** outDiagnostics);\n   313→\n   314→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCode(\n   315→        SlangInt targetIndex,\n   316→        slang::IBlob** outCode,\n   317→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n   318→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointMetadata(\n   319→        SlangInt entryPointIndex,\n   320→        SlangInt targetIndex,\n   321→        slang::IMetadata** outMetadata,\n   322→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   323→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetMetadata(\n   324→        SlangInt targetIndex,\n   325→        slang::IMetadata** outMetadata,\n   326→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n   327→\n   328→    SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n   329→        SlangInt entryPointIndex,\n   330→        SlangInt targetIndex,\n   331→        ISlangMutableFileSystem** outFileSystem) SLANG_OVERRIDE;\n   332→\n   333→    SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n   334→        slang::SpecializationArg const* specializationArgs,\n   335→        SlangInt specializationArgCount,\n   336→        slang::IComponentType** outSpecializedComponentType,\n   337→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE;\n   338→    SLANG_NO_THROW SlangResult SLANG_MCALL\n   339→    renameEntryPoint(const char* newName, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE;\n   340→    SLANG_NO_THROW SlangResult SLANG_MCALL link(\n   341→        slang::IComponentType** outLinkedComponentType,\n   342→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE;\n   343→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n   344→        int entryPointIndex,\n   345→        int targetIndex,\n   346→        ISlangSharedLibrary** outSharedLibrary,\n   347→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   348→\n   349→    /// ComponentType is the only class inheriting from IComponentType that provides a\n   350→    /// meaningful implementation for this function. All others should forward these and\n   351→    /// implement `buildHash`.\n   352→    SLANG_NO_THROW void SLANG_MCALL getEntryPointHash(\n   353→        SlangInt entryPointIndex,\n   354→        SlangInt targetIndex,\n   355→        slang::IBlob** outHash) SLANG_OVERRIDE;\n   356→\n   357→    SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n   358→        slang::IComponentType** outLinkedComponentType,\n   359→        uint32_t count,\n   360→        slang::CompilerOptionEntry* entries,\n   361→        ISlangBlob** outDiagnostics) override;\n   362→\n   363→    //\n   364→    // slang::IComponentType2 interface\n   365→    //\n   366→\n   367→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCompileResult(\n   368→        SlangInt entryPointIndex,\n   369→        SlangInt targetIndex,\n   370→        slang::ICompileResult** outCompileResult,\n   371→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   372→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCompileResult(\n   373→        SlangInt targetIndex,\n   374→        slang::ICompileResult** outCompileResult,\n   375→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n   376→\n   377→    //\n   378→    // slang::IModulePrecompileService interface\n   379→    //\n   380→    SLANG_NO_THROW SlangResult SLANG_MCALL\n   381→    precompileForTarget(SlangCompileTarget target, slang::IBlob** outDiagnostics) SLANG_OVERRIDE;\n   382→\n   383→    SLANG_NO_THROW SlangResult SLANG_MCALL getPrecompiledTargetCode(\n   384→        SlangCompileTarget target,\n   385→        slang::IBlob** outCode,\n   386→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n   387→\n   388→    SLANG_NO_THROW SlangInt SLANG_MCALL getModuleDependencyCount() SLANG_OVERRIDE;\n   389→\n   390→    SLANG_NO_THROW SlangResult SLANG_MCALL getModuleDependency(\n   391→        SlangInt dependencyIndex,\n   392→        slang::IModule** outModule,\n   393→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n   394→\n   395→    CompilerOptionSet& getOptionSet() { return m_optionSet; }\n   396→\n   397→    /// Get the linkage (aka \"session\" in the public API) for this component type.\n   398→    Linkage* getLinkage() { return m_linkage; }\n   399→\n   400→    /// Get the target-specific version of this program for the given `target`.\n   401→    ///\n   402→    /// The `target` must be a target on the `Linkage` that was used to create this program.\n   403→    TargetProgram* getTargetProgram(TargetRequest* target);\n   404→\n   405→    /// Update the hash builder with the dependencies for this component type.\n   406→    virtual void buildHash(DigestBuilder<SHA1>& builder) = 0;\n   407→\n   408→    /// Get the number of entry points linked into this component type.\n   409→    virtual Index getEntryPointCount() = 0;\n   410→\n   411→    /// Get one of the entry points linked into this component type.\n   412→    virtual RefPtr<EntryPoint> getEntryPoint(Index index) = 0;\n   413→\n   414→    /// Get the mangled name of one of the entry points linked into this component type.\n   415→    virtual String getEntryPointMangledName(Index index) = 0;\n   416→\n   417→    /// Get the name override of one of the entry points linked into this component type.\n   418→    virtual String getEntryPointNameOverride(Index index) = 0;\n   419→\n   420→    /// Get the number of global shader parameters linked into this component type.\n   421→    virtual Index getShaderParamCount() = 0;\n   422→\n   423→    /// Get one of the global shader parametesr linked into this component type.\n   424→    virtual ShaderParamInfo getShaderParam(Index index) = 0;\n   425→\n   426→    /// Get the specialization parameter at `index`.\n   427→    virtual SpecializationParam const& getSpecializationParam(Index index) = 0;\n   428→\n   429→    /// Get the number of \"requirements\" that this component type has.\n   430→    ///\n   431→    /// A requirement represents another component type that this component\n   432→    /// needs in order to function correctly. For example, the dependency\n   433→    /// of one module on another module that it `import`s is represented\n   434→    /// as a requirement, as is the dependency of an entry point on the\n   435→    /// module that defines it.\n   436→    ///\n   437→    virtual Index getRequirementCount() = 0;\n   438→\n   439→    /// Get the requirement at `index`.\n   440→    virtual RefPtr<ComponentType> getRequirement(Index index) = 0;\n   441→\n   442→    /// Parse a type from a string, in the context of this component type.\n   443→    ///\n   444→    /// Any names in the string will be resolved using the modules\n   445→    /// referenced by the program.\n   446→    ///\n   447→    /// On an error, returns null and reports diagnostic messages\n   448→    /// to the provided `sink`.\n   449→    ///\n   450→    /// TODO: This function shouldn't be on the base class, since\n   451→    /// it only really makes sense on `Module`.\n   452→    ///\n   453→    Type* getTypeFromString(String const& typeStr, DiagnosticSink* sink);\n   454→\n   455→    Expr* findDeclFromString(String const& name, DiagnosticSink* sink);\n   456→\n   457→    Expr* findDeclFromStringInType(\n   458→        Type* type,\n   459→        String const& name,\n   460→        LookupMask mask,\n   461→        DiagnosticSink* sink);\n   462→\n   463→    bool isSubType(Type* subType, Type* superType);\n   464→\n   465→    Dictionary<String, IntVal*>& getMangledNameToIntValMap();\n   466→    ConstantIntVal* tryFoldIntVal(IntVal* intVal);\n   467→\n   468→    /// Get a list of modules that this component type depends on.\n   469→    ///\n   470→    virtual List<Module*> const& getModuleDependencies() = 0;\n   471→\n   472→    /// Get the full list of source files this component type depends on.\n   473→    ///\n   474→    virtual List<SourceFile*> const& getFileDependencies() = 0;\n   475→\n   476→    /// Callback for use with `enumerateIRModules`\n   477→    typedef void (*EnumerateIRModulesCallback)(IRModule* irModule, void* userData);\n   478→\n   479→    /// Invoke `callback` on all the IR modules that are (transitively) linked into this component\n   480→    /// type.\n   481→    void enumerateIRModules(EnumerateIRModulesCallback callback, void* userData);\n   482→\n   483→    /// Invoke `callback` on all the IR modules that are (transitively) linked into this component\n   484→    /// type.\n   485→    template<typename F>\n   486→    void enumerateIRModules(F const& callback)\n   487→    {\n   488→        struct Helper\n   489→        {\n   490→            static void helper(IRModule* irModule, void* userData) { (*(F*)userData)(irModule); }\n   491→        };\n   492→        enumerateIRModules(&Helper::helper, (void*)&callback);\n   493→    }\n   494→\n   495→    /// Callback for use with `enumerateModules`\n   496→    typedef void (*EnumerateModulesCallback)(Module* module, void* userData);\n   497→\n   498→    /// Invoke `callback` on all the modules that are (transitively) linked into this component\n   499→    /// type.\n   500→    void enumerateModules(EnumerateModulesCallback callback, void* userData);\n   501→\n   502→    /// Invoke `callback` on all the modules that are (transitively) linked into this component\n   503→    /// type.\n   504→    template<typename F>\n   505→    void enumerateModules(F const& callback)\n   506→    {\n   507→        struct Helper\n   508→        {\n   509→            static void helper(Module* module, void* userData) { (*(F*)userData)(module); }\n   510→        };\n   511→        enumerateModules(&Helper::helper, (void*)&callback);\n   512→    }\n   513→\n   514→    /// Side-band information generated when specializing this component type.\n   515→    ///\n   516→    /// Difference subclasses of `ComponentType` are expected to create their\n   517→    /// own subclass of `SpecializationInfo` as the output of `_validateSpecializationArgs`.\n   518→    /// Later, whenever we want to use a specialized component type we will\n   519→    /// also have the `SpecializationInfo` available and will expect it to\n   520→    /// have the correct (subclass-specific) type.\n   521→    ///\n   522→    class SpecializationInfo : public RefObject\n   523→    {\n   524→    };\n   525→\n   526→    /// Validate the given specialization `args` and compute any side-band specialization info.\n   527→    ///\n   528→    /// Any errors will be reported to `sink`, which can thus be used to test\n   529→    /// if the operation was successful.\n   530→    ///\n   531→    /// A null return value is allowed, since not all subclasses require\n   532→    /// custom side-band specialization information.\n   533→    ///\n   534→    /// This function is an implementation detail of `specialize()`.\n   535→    ///\n   536→    virtual RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n   537→        SpecializationArg const* args,\n   538→        Index argCount,\n   539→        DiagnosticSink* sink) = 0;\n   540→\n   541→    /// Validate the given specialization `args` and compute any side-band specialization info.\n   542→    ///\n   543→    /// Any errors will be reported to `sink`, which can thus be used to test\n   544→    /// if the operation was successful.\n   545→    ///\n   546→    /// A null return value is allowed, since not all subclasses require\n   547→    /// custom side-band specialization information.\n   548→    ///\n   549→    /// This function is an implementation detail of `specialize()`.\n   550→    ///\n   551→    RefPtr<SpecializationInfo> _validateSpecializationArgs(\n   552→        SpecializationArg const* args,\n   553→        Index argCount,\n   554→        DiagnosticSink* sink)\n   555→    {\n   556→        if (argCount == 0)\n   557→            return nullptr;\n   558→        return _validateSpecializationArgsImpl(args, argCount, sink);\n   559→    }\n   560→\n   561→    /// Specialize this component type given `specializationArgs`\n   562→    ///\n   563→    /// Any diagnostics will be reported to `sink`, which can be used\n   564→    /// to determine if the operation was successful. It is allowed\n   565→    /// for this operation to have a non-null return even when an\n   566→    /// error is ecnountered.\n   567→    ///\n   568→    RefPtr<ComponentType> specialize(\n   569→        SpecializationArg const* specializationArgs,\n   570→        SlangInt specializationArgCount,\n   571→        DiagnosticSink* sink);\n   572→\n   573→    /// Invoke `visitor` on this component type, using the appropriate dynamic type.\n   574→    ///\n   575→    /// This function implements the \"visitor pattern\" for `ComponentType`.\n   576→    ///\n   577→    /// If the `specializationInfo` argument is non-null, it must be specialization\n   578→    /// information generated for this specific component type by `_validateSpecializationArgs`.\n   579→    /// In that case, appropriately-typed specialization information will be passed\n   580→    /// when invoking the `visitor`.\n   581→    ///\n   582→    virtual void acceptVisitor(\n   583→        ComponentTypeVisitor* visitor,\n   584→        SpecializationInfo* specializationInfo) = 0;\n   585→\n   586→    /// Create a scope suitable for looking up names or parsing specialization arguments.\n   587→    ///\n   588→    /// This facility is only needed to support legacy APIs for string-based lookup\n   589→    /// and parsing via Slang reflection, and is not recommended for future APIs to use.\n   590→    ///\n   591→    Scope* _getOrCreateScopeForLegacyLookup(ASTBuilder* astBuilder);\n   592→\n   593→protected:\n   594→    ComponentType(Linkage* linkage);\n   595→\n   596→protected:\n   597→    Linkage* m_linkage;\n   598→\n   599→    CompilerOptionSet m_optionSet;\n   600→\n   601→    // Cache of target-specific programs for each target.\n   602→    Dictionary<TargetRequest*, RefPtr<TargetProgram>> m_targetPrograms;\n   603→\n   604→    // Any types looked up dynamically using `getTypeFromString`\n   605→    //\n   606→    // TODO: Remove this. Type lookup should only be supported on `Module`s.\n   607→    //\n   608→    Dictionary<String, Type*> m_types;\n   609→\n   610→    // Any decls looked up dynamically using `findDeclFromString`.\n   611→    Dictionary<String, Expr*> m_decls;\n   612→\n   613→    Scope* m_lookupScope = nullptr;\n   614→    std::unique_ptr<Dictionary<String, IntVal*>> m_mapMangledNameToIntVal;\n   615→\n   616→    Dictionary<Int, ComPtr<IArtifact>> m_targetArtifacts;\n   617→};\n   618→\n   619→/// A component type built up from other component types.\n   620→class CompositeComponentType : public ComponentType\n   621→{\n   622→public:\n   623→    static RefPtr<ComponentType> create(\n   624→        Linkage* linkage,\n   625→        List<RefPtr<ComponentType>> const& childComponents);\n   626→\n   627→    virtual void buildHash(DigestBuilder<SHA1>& builder) SLANG_OVERRIDE;\n   628→\n   629→    List<RefPtr<ComponentType>> const& getChildComponents() { return m_childComponents; };\n   630→    Index getChildComponentCount() { return m_childComponents.getCount(); }\n   631→    RefPtr<ComponentType> getChildComponent(Index index) { return m_childComponents[index]; }\n   632→\n   633→    Index getEntryPointCount() SLANG_OVERRIDE;\n   634→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE;\n   635→    String getEntryPointMangledName(Index index) SLANG_OVERRIDE;\n   636→    String getEntryPointNameOverride(Index index) SLANG_OVERRIDE;\n   637→\n   638→    Index getShaderParamCount() SLANG_OVERRIDE;\n   639→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE;\n   640→\n   641→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE;\n   642→    SpecializationParam const& getSpecializationParam(Index index) SLANG_OVERRIDE;\n   643→\n   644→    Index getRequirementCount() SLANG_OVERRIDE;\n   645→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE;\n   646→\n   647→    List<Module*> const& getModuleDependencies() SLANG_OVERRIDE;\n   648→    List<SourceFile*> const& getFileDependencies() SLANG_OVERRIDE;\n   649→\n   650→    class CompositeSpecializationInfo : public SpecializationInfo\n   651→    {\n   652→    public:\n   653→        List<RefPtr<SpecializationInfo>> childInfos;\n   654→    };\n   655→\n   656→protected:\n   657→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n   658→        SLANG_OVERRIDE;\n   659→\n   660→\n   661→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n   662→        SpecializationArg const* args,\n   663→        Index argCount,\n   664→        DiagnosticSink* sink) SLANG_OVERRIDE;\n   665→\n   666→public:\n   667→    CompositeComponentType(Linkage* linkage, List<RefPtr<ComponentType>> const& childComponents);\n   668→\n   669→private:\n   670→    List<RefPtr<ComponentType>> m_childComponents;\n   671→\n   672→    // The following arrays hold the concatenated entry points, parameters,\n   673→    // etc. from the child components. This approach allows for reasonably\n   674→    // fast (constant time) access through operations like `getShaderParam`,\n   675→    // but means that the memory usage of a composite is proportional to\n   676→    // the sum of the memory usage of the children, rather than being fixed\n   677→    // by the number of children (as it would be if we just stored\n   678→    // `m_childComponents`).\n   679→    //\n   680→    // TODO: We could conceivably build some O(numChildren) arrays that\n   681→    // support binary-search to provide logarithmic-time access to entry\n   682→    // points, parameters, etc. while giving a better overall memory usage.\n   683→    //\n   684→    List<EntryPoint*> m_entryPoints;\n   685→    List<String> m_entryPointMangledNames;\n   686→    List<String> m_entryPointNameOverrides;\n   687→    List<ShaderParamInfo> m_shaderParams;\n   688→    List<SpecializationParam> m_specializationParams;\n   689→    List<ComponentType*> m_requirements;\n   690→\n   691→    ModuleDependencyList m_moduleDependencyList;\n   692→    FileDependencyList m_fileDependencyList;\n   693→};\n   694→\n   695→/// A component type created by specializing another component type.\n   696→class SpecializedComponentType : public ComponentType\n   697→{\n   698→public:\n   699→    SpecializedComponentType(\n   700→        ComponentType* base,\n   701→        SpecializationInfo* specializationInfo,\n   702→        List<SpecializationArg> const& specializationArgs,\n   703→        DiagnosticSink* sink);\n   704→\n   705→    virtual void buildHash(DigestBuilder<SHA1>& builer) SLANG_OVERRIDE;\n   706→\n   707→    /// Get the base (unspecialized) component type that is being specialized.\n   708→    RefPtr<ComponentType> getBaseComponentType() { return m_base; }\n   709→\n   710→    RefPtr<SpecializationInfo> getSpecializationInfo() { return m_specializationInfo; }\n   711→\n   712→    /// Get the number of arguments supplied for existential type parameters.\n   713→    ///\n   714→    /// Note that the number of arguments may not match the number of parameters.\n   715→    /// In particular, an unspecialized entry point may have many parameters, but zero arguments.\n   716→    Index getSpecializationArgCount() { return m_specializationArgs.getCount(); }\n   717→\n   718→    /// Get the existential type argument (type and witness table) at `index`.\n   719→    SpecializationArg const& getSpecializationArg(Index index)\n   720→    {\n   721→        return m_specializationArgs[index];\n   722→    }\n   723→\n   724→    /// Get an array of all existential type arguments.\n   725→    SpecializationArg const* getSpecializationArgs() { return m_specializationArgs.getBuffer(); }\n   726→\n   727→    Index getEntryPointCount() SLANG_OVERRIDE { return m_base->getEntryPointCount(); }\n   728→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE\n   729→    {\n   730→        return m_base->getEntryPoint(index);\n   731→    }\n   732→    String getEntryPointMangledName(Index index) SLANG_OVERRIDE;\n   733→    String getEntryPointNameOverride(Index index) SLANG_OVERRIDE;\n   734→\n   735→    Index getShaderParamCount() SLANG_OVERRIDE { return m_base->getShaderParamCount(); }\n   736→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE\n   737→    {\n   738→        return m_base->getShaderParam(index);\n   739→    }\n   740→\n   741→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE { return 0; }\n   742→    SpecializationParam const& getSpecializationParam(Index index) SLANG_OVERRIDE\n   743→    {\n   744→        SLANG_UNUSED(index);\n   745→        static SpecializationParam dummy;\n   746→        return dummy;\n   747→    }\n   748→\n   749→    Index getRequirementCount() SLANG_OVERRIDE;\n   750→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE;\n   751→\n   752→    List<Module*> const& getModuleDependencies() SLANG_OVERRIDE { return m_moduleDependencies; }\n   753→    List<SourceFile*> const& getFileDependencies() SLANG_OVERRIDE { return m_fileDependencies; }\n   754→\n   755→    RefPtr<IRModule> getIRModule() { return m_irModule; }\n   756→\n   757→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n   758→        SLANG_OVERRIDE;\n   759→\n   760→protected:\n   761→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n   762→        SpecializationArg const* args,\n   763→        Index argCount,\n   764→        DiagnosticSink* sink) SLANG_OVERRIDE\n   765→    {\n   766→        SLANG_UNUSED(args);\n   767→        SLANG_UNUSED(argCount);\n   768→        SLANG_UNUSED(sink);\n   769→        return nullptr;\n   770→    }\n   771→\n   772→private:\n   773→    RefPtr<ComponentType> m_base;\n   774→    RefPtr<SpecializationInfo> m_specializationInfo;\n   775→    SpecializationArgs m_specializationArgs;\n   776→    RefPtr<IRModule> m_irModule;\n   777→\n   778→    List<String> m_entryPointMangledNames;\n   779→    List<String> m_entryPointNameOverrides;\n   780→\n   781→    List<Module*> m_moduleDependencies;\n   782→    List<SourceFile*> m_fileDependencies;\n   783→    List<RefPtr<ComponentType>> m_requirements;\n   784→};\n   785→\n   786→class RenamedEntryPointComponentType : public ComponentType\n   787→{\n   788→public:\n   789→    using Super = ComponentType;\n   790→\n   791→    RenamedEntryPointComponentType(ComponentType* base, String newName);\n   792→\n   793→    ComponentType* getBase() { return m_base.Ptr(); }\n   794→\n   795→    // Forward `IComponentType` methods\n   796→\n   797→    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n   798→    {\n   799→        return Super::getSession();\n   800→    }\n   801→\n   802→    SLANG_NO_THROW slang::ProgramLayout* SLANG_MCALL\n   803→    getLayout(SlangInt targetIndex, slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   804→    {\n   805→        return Super::getLayout(targetIndex, outDiagnostics);\n   806→    }\n   807→\n   808→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n   809→        SlangInt entryPointIndex,\n   810→        SlangInt targetIndex,\n   811→        slang::IBlob** outCode,\n   812→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   813→    {\n   814→        return Super::getEntryPointCode(entryPointIndex, targetIndex, outCode, outDiagnostics);\n   815→    }\n   816→\n   817→    SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n   818→        slang::SpecializationArg const* specializationArgs,\n   819→        SlangInt specializationArgCount,\n   820→        slang::IComponentType** outSpecializedComponentType,\n   821→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n   822→    {\n   823→        return Super::specialize(\n   824→            specializationArgs,\n   825→            specializationArgCount,\n   826→            outSpecializedComponentType,\n   827→            outDiagnostics);\n   828→    }\n   829→\n   830→    SLANG_NO_THROW SlangResult SLANG_MCALL\n   831→    renameEntryPoint(const char* newName, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE\n   832→    {\n   833→        return Super::renameEntryPoint(newName, outEntryPoint);\n   834→    }\n   835→\n   836→    SLANG_NO_THROW SlangResult SLANG_MCALL\n   837→    link(slang::IComponentType** outLinkedComponentType, ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n   838→    {\n   839→        return Super::link(outLinkedComponentType, outDiagnostics);\n   840→    }\n   841→\n   842→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n   843→        int entryPointIndex,\n   844→        int targetIndex,\n   845→        ISlangSharedLibrary** outSharedLibrary,\n   846→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   847→    {\n   848→        return Super::getEntryPointHostCallable(\n   849→            entryPointIndex,\n   850→            targetIndex,\n   851→            outSharedLibrary,\n   852→            outDiagnostics);\n   853→    }\n   854→\n   855→    List<Module*> const& getModuleDependencies() SLANG_OVERRIDE\n   856→    {\n   857→        return m_base->getModuleDependencies();\n   858→    }\n   859→    List<SourceFile*> const& getFileDependencies() SLANG_OVERRIDE\n   860→    {\n   861→        return m_base->getFileDependencies();\n   862→    }\n   863→\n   864→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE\n   865→    {\n   866→        return m_base->getSpecializationParamCount();\n   867→    }\n   868→\n   869→    SpecializationParam const& getSpecializationParam(Index index) SLANG_OVERRIDE\n   870→    {\n   871→        return m_base->getSpecializationParam(index);\n   872→    }\n   873→\n   874→    Index getRequirementCount() SLANG_OVERRIDE { return m_base->getRequirementCount(); }\n   875→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE\n   876→    {\n   877→        return m_base->getRequirement(index);\n   878→    }\n   879→    Index getEntryPointCount() SLANG_OVERRIDE { return m_base->getEntryPointCount(); }\n   880→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE\n   881→    {\n   882→        return m_base->getEntryPoint(index);\n   883→    }\n   884→    String getEntryPointMangledName(Index index) SLANG_OVERRIDE\n   885→    {\n   886→        return m_base->getEntryPointMangledName(index);\n   887→    }\n   888→    String getEntryPointNameOverride(Index index) SLANG_OVERRIDE\n   889→    {\n   890→        SLANG_UNUSED(index);\n   891→        SLANG_ASSERT(index == 0);\n   892→        return m_entryPointNameOverride;\n   893→    }\n   894→\n   895→    Index getShaderParamCount() SLANG_OVERRIDE { return m_base->getShaderParamCount(); }\n   896→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE\n   897→    {\n   898→        return m_base->getShaderParam(index);\n   899→    }\n   900→\n   901→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n   902→        SLANG_OVERRIDE;\n   903→\n   904→    virtual void buildHash(DigestBuilder<SHA1>& builder) SLANG_OVERRIDE;\n   905→\n   906→private:\n   907→    RefPtr<ComponentType> m_base;\n   908→    String m_entryPointNameOverride;\n   909→\n   910→protected:\n   911→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n   912→        SpecializationArg const* args,\n   913→        Index argCount,\n   914→        DiagnosticSink* sink) SLANG_OVERRIDE\n   915→    {\n   916→        return m_base->_validateSpecializationArgsImpl(args, argCount, sink);\n   917→    }\n   918→};\n   919→\n   920→/// Describes an entry point for the purposes of layout and code generation.\n   921→///\n   922→/// This class also tracks any generic arguments to the entry point,\n   923→/// in the case that it is a specialization of a generic entry point.\n   924→///\n   925→/// There is also a provision for creating a \"dummy\" entry point for\n   926→/// the purposes of pass-through compilation modes. Only the\n   927→/// `getName()` and `getProfile()` methods should be expected to\n   928→/// return useful data on pass-through entry points.\n   929→///\n   930→class EntryPoint : public ComponentType, public slang::IEntryPoint\n   931→{\n   932→    typedef ComponentType Super;\n   933→\n   934→public:\n   935→    SLANG_REF_OBJECT_IUNKNOWN_ALL\n   936→\n   937→    ISlangUnknown* getInterface(const Guid& guid);\n   938→\n   939→\n   940→    // Forward `IComponentType` methods\n   941→\n   942→    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n   943→    {\n   944→        return Super::getSession();\n   945→    }\n   946→\n   947→    SLANG_NO_THROW slang::ProgramLayout* SLANG_MCALL\n   948→    getLayout(SlangInt targetIndex, slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   949→    {\n   950→        return Super::getLayout(targetIndex, outDiagnostics);\n   951→    }\n   952→\n   953→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n   954→        SlangInt entryPointIndex,\n   955→        SlangInt targetIndex,\n   956→        slang::IBlob** outCode,\n   957→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   958→    {\n   959→        return Super::getEntryPointCode(entryPointIndex, targetIndex, outCode, outDiagnostics);\n   960→    }\n   961→\n   962→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCode(\n   963→        SlangInt targetIndex,\n   964→        slang::IBlob** outCode,\n   965→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   966→    {\n   967→        return Super::getTargetCode(targetIndex, outCode, outDiagnostics);\n   968→    }\n   969→\n   970→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointMetadata(\n   971→        SlangInt entryPointIndex,\n   972→        SlangInt targetIndex,\n   973→        slang::IMetadata** outMetadata,\n   974→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   975→    {\n   976→        return Super::getEntryPointMetadata(\n   977→            entryPointIndex,\n   978→            targetIndex,\n   979→            outMetadata,\n   980→            outDiagnostics);\n   981→    }\n   982→\n   983→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetMetadata(\n   984→        SlangInt targetIndex,\n   985→        slang::IMetadata** outMetadata,\n   986→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   987→    {\n   988→        return Super::getTargetMetadata(targetIndex, outMetadata, outDiagnostics);\n   989→    }\n   990→\n   991→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCompileResult(\n   992→        SlangInt entryPointIndex,\n   993→        SlangInt targetIndex,\n   994→        slang::ICompileResult** outCompileResult,\n   995→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n   996→    {\n   997→        return Super::getEntryPointCompileResult(\n   998→            entryPointIndex,\n   999→            targetIndex,\n  1000→            outCompileResult,\n  1001→            outDiagnostics);\n  1002→    }\n  1003→\n  1004→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCompileResult(\n  1005→        SlangInt targetIndex,\n  1006→        slang::ICompileResult** outCompileResult,\n  1007→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1008→    {\n  1009→        return Super::getTargetCompileResult(targetIndex, outCompileResult, outDiagnostics);\n  1010→    }\n  1011→\n  1012→    SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n  1013→        SlangInt entryPointIndex,\n  1014→        SlangInt targetIndex,\n  1015→        ISlangMutableFileSystem** outFileSystem) SLANG_OVERRIDE\n  1016→    {\n  1017→        return Super::getResultAsFileSystem(entryPointIndex, targetIndex, outFileSystem);\n  1018→    }\n  1019→\n  1020→    SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n  1021→        slang::SpecializationArg const* specializationArgs,\n  1022→        SlangInt specializationArgCount,\n  1023→        slang::IComponentType** outSpecializedComponentType,\n  1024→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1025→    {\n  1026→        return Super::specialize(\n  1027→            specializationArgs,\n  1028→            specializationArgCount,\n  1029→            outSpecializedComponentType,\n  1030→            outDiagnostics);\n  1031→    }\n  1032→\n  1033→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1034→    renameEntryPoint(const char* newName, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE\n  1035→    {\n  1036→        return Super::renameEntryPoint(newName, outEntryPoint);\n  1037→    }\n  1038→\n  1039→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1040→    link(slang::IComponentType** outLinkedComponentType, ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1041→    {\n  1042→        return Super::link(outLinkedComponentType, outDiagnostics);\n  1043→    }\n  1044→\n  1045→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n  1046→        slang::IComponentType** outLinkedComponentType,\n  1047→        uint32_t count,\n  1048→        slang::CompilerOptionEntry* entries,\n  1049→        ISlangBlob** outDiagnostics) override\n  1050→    {\n  1051→        return Super::linkWithOptions(outLinkedComponentType, count, entries, outDiagnostics);\n  1052→    }\n  1053→\n  1054→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n  1055→        int entryPointIndex,\n  1056→        int targetIndex,\n  1057→        ISlangSharedLibrary** outSharedLibrary,\n  1058→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1059→    {\n  1060→        return Super::getEntryPointHostCallable(\n  1061→            entryPointIndex,\n  1062→            targetIndex,\n  1063→            outSharedLibrary,\n  1064→            outDiagnostics);\n  1065→    }\n  1066→\n  1067→    SLANG_NO_THROW void SLANG_MCALL getEntryPointHash(\n  1068→        SlangInt entryPointIndex,\n  1069→        SlangInt targetIndex,\n  1070→        slang::IBlob** outHash) SLANG_OVERRIDE\n  1071→    {\n  1072→        return Super::getEntryPointHash(entryPointIndex, targetIndex, outHash);\n  1073→    }\n  1074→\n  1075→    virtual void buildHash(DigestBuilder<SHA1>& builder) SLANG_OVERRIDE;\n  1076→\n  1077→    /// Create an entry point that refers to the given function.\n  1078→    static RefPtr<EntryPoint> create(\n  1079→        Linkage* linkage,\n  1080→        DeclRef<FuncDecl> funcDeclRef,\n  1081→        Profile profile);\n  1082→\n  1083→    /// Get the function decl-ref, including any generic arguments.\n  1084→    DeclRef<FuncDecl> getFuncDeclRef() { return m_funcDeclRef; }\n  1085→\n  1086→    /// Get the function declaration (without generic arguments).\n  1087→    FuncDecl* getFuncDecl() { return m_funcDeclRef.getDecl(); }\n  1088→\n  1089→    /// Get the name of the entry point\n  1090→    Name* getName() { return m_name; }\n  1091→\n  1092→    /// Get the profile associated with the entry point\n  1093→    ///\n  1094→    /// Note: only the stage part of the profile is expected\n  1095→    /// to contain useful data, but certain legacy code paths\n  1096→    /// allow for \"shader model\" information to come via this path.\n  1097→    ///\n  1098→    Profile getProfile() { return m_profile; }\n  1099→\n  1100→    /// Get the stage that the entry point is for.\n  1101→    Stage getStage() { return m_profile.getStage(); }\n  1102→\n  1103→    /// Get the module that contains the entry point.\n  1104→    Module* getModule();\n  1105→\n  1106→    /// Get a list of modules that this entry point depends on.\n  1107→    ///\n  1108→    /// This will include the module that defines the entry point (see `getModule()`),\n  1109→    /// but may also include modules that are required by its generic type arguments.\n  1110→    ///\n  1111→    List<Module*> const& getModuleDependencies()\n  1112→        SLANG_OVERRIDE; // { return getModule()->getModuleDependencies(); }\n  1113→    List<SourceFile*> const& getFileDependencies()\n  1114→        SLANG_OVERRIDE; // { return getModule()->getFileDependencies(); }\n  1115→\n  1116→    /// Create a dummy `EntryPoint` that is only usable for pass-through compilation.\n  1117→    static RefPtr<EntryPoint> createDummyForPassThrough(\n  1118→        Linkage* linkage,\n  1119→        Name* name,\n  1120→        Profile profile);\n  1121→\n  1122→    /// Create a dummy `EntryPoint` that stands in for a serialized entry point\n  1123→    static RefPtr<EntryPoint> createDummyForDeserialize(\n  1124→        Linkage* linkage,\n  1125→        Name* name,\n  1126→        Profile profile,\n  1127→        String mangledName);\n  1128→\n  1129→    /// Get the number of existential type parameters for the entry point.\n  1130→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE;\n  1131→\n  1132→    /// Get the existential type parameter at `index`.\n  1133→    SpecializationParam const& getSpecializationParam(Index index) SLANG_OVERRIDE;\n  1134→\n  1135→    Index getRequirementCount() SLANG_OVERRIDE;\n  1136→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE;\n  1137→\n  1138→    SpecializationParams const& getExistentialSpecializationParams()\n  1139→    {\n  1140→        return m_existentialSpecializationParams;\n  1141→    }\n  1142→\n  1143→    Index getGenericSpecializationParamCount() { return m_genericSpecializationParams.getCount(); }\n  1144→    Index getExistentialSpecializationParamCount()\n  1145→    {\n  1146→        return m_existentialSpecializationParams.getCount();\n  1147→    }\n  1148→\n  1149→    /// Get an array of all entry-point shader parameters.\n  1150→    List<ShaderParamInfo> const& getShaderParams() { return m_shaderParams; }\n  1151→\n  1152→    Index getEntryPointCount() SLANG_OVERRIDE { return 1; };\n  1153→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE\n  1154→    {\n  1155→        SLANG_UNUSED(index);\n  1156→        return this;\n  1157→    }\n  1158→    String getEntryPointMangledName(Index index) SLANG_OVERRIDE;\n  1159→    String getEntryPointNameOverride(Index index) SLANG_OVERRIDE;\n  1160→\n  1161→    Index getShaderParamCount() SLANG_OVERRIDE { return 0; }\n  1162→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE\n  1163→    {\n  1164→        SLANG_UNUSED(index);\n  1165→        return ShaderParamInfo();\n  1166→    }\n  1167→\n  1168→    class EntryPointSpecializationInfo : public SpecializationInfo\n  1169→    {\n  1170→    public:\n  1171→        DeclRef<FuncDecl> specializedFuncDeclRef;\n  1172→        List<ExpandedSpecializationArg> existentialSpecializationArgs;\n  1173→    };\n  1174→\n  1175→    SLANG_NO_THROW slang::FunctionReflection* SLANG_MCALL getFunctionReflection() SLANG_OVERRIDE\n  1176→    {\n  1177→        return (slang::FunctionReflection*)m_funcDeclRef.declRefBase;\n  1178→    }\n  1179→\n  1180→protected:\n  1181→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n  1182→        SLANG_OVERRIDE;\n  1183→\n  1184→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n  1185→        SpecializationArg const* args,\n  1186→        Index argCount,\n  1187→        DiagnosticSink* sink) SLANG_OVERRIDE;\n  1188→\n  1189→private:\n  1190→    EntryPoint(Linkage* linkage, Name* name, Profile profile, DeclRef<FuncDecl> funcDeclRef);\n  1191→\n  1192→    void _collectGenericSpecializationParamsRec(Decl* decl);\n  1193→    void _collectShaderParams();\n  1194→\n  1195→    // The name of the entry point function (e.g., `main`)\n  1196→    //\n  1197→    Name* m_name = nullptr;\n  1198→\n  1199→    // The declaration of the entry-point function itself.\n  1200→    //\n  1201→    DeclRef<FuncDecl> m_funcDeclRef;\n  1202→\n  1203→    /// The mangled name of the entry point function\n  1204→    String m_mangledName;\n  1205→\n  1206→    SpecializationParams m_genericSpecializationParams;\n  1207→    SpecializationParams m_existentialSpecializationParams;\n  1208→\n  1209→    /// Information about entry-point parameters\n  1210→    List<ShaderParamInfo> m_shaderParams;\n  1211→\n  1212→    // The profile that the entry point will be compiled for\n  1213→    // (this is a combination of the target stage, and also\n  1214→    // a feature level that sets capabilities)\n  1215→    //\n  1216→    // Note: the profile-version part of this should probably\n  1217→    // be moving towards deprecation, in favor of the version\n  1218→    // information (e.g., \"Shader Model 5.1\") always coming\n  1219→    // from the target, while the stage part is all that is\n  1220→    // intrinsic to the entry point.\n  1221→    //\n  1222→    Profile m_profile;\n  1223→};\n  1224→\n  1225→class TypeConformance : public ComponentType, public slang::ITypeConformance\n  1226→{\n  1227→    typedef ComponentType Super;\n  1228→\n  1229→public:\n  1230→    SLANG_REF_OBJECT_IUNKNOWN_ALL\n  1231→\n  1232→    ISlangUnknown* getInterface(const Guid& guid);\n  1233→\n  1234→    TypeConformance(\n  1235→        Linkage* linkage,\n  1236→        SubtypeWitness* witness,\n  1237→        Int confomrmanceIdOverride,\n  1238→        DiagnosticSink* sink);\n  1239→\n  1240→    // Forward `IComponentType` methods\n  1241→\n  1242→    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n  1243→    {\n  1244→        return Super::getSession();\n  1245→    }\n  1246→\n  1247→    SLANG_NO_THROW slang::ProgramLayout* SLANG_MCALL\n  1248→    getLayout(SlangInt targetIndex, slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1249→    {\n  1250→        return Super::getLayout(targetIndex, outDiagnostics);\n  1251→    }\n  1252→\n  1253→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n  1254→        SlangInt entryPointIndex,\n  1255→        SlangInt targetIndex,\n  1256→        slang::IBlob** outCode,\n  1257→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1258→    {\n  1259→        return Super::getEntryPointCode(entryPointIndex, targetIndex, outCode, outDiagnostics);\n  1260→    }\n  1261→\n  1262→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCode(\n  1263→        SlangInt targetIndex,\n  1264→        slang::IBlob** outCode,\n  1265→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1266→    {\n  1267→        return Super::getTargetCode(targetIndex, outCode, outDiagnostics);\n  1268→    }\n  1269→\n  1270→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointMetadata(\n  1271→        SlangInt entryPointIndex,\n  1272→        SlangInt targetIndex,\n  1273→        slang::IMetadata** outMetadata,\n  1274→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1275→    {\n  1276→        return Super::getEntryPointMetadata(\n  1277→            entryPointIndex,\n  1278→            targetIndex,\n  1279→            outMetadata,\n  1280→            outDiagnostics);\n  1281→    }\n  1282→\n  1283→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetMetadata(\n  1284→        SlangInt targetIndex,\n  1285→        slang::IMetadata** outMetadata,\n  1286→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1287→    {\n  1288→        return Super::getTargetMetadata(targetIndex, outMetadata, outDiagnostics);\n  1289→    }\n  1290→\n  1291→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCompileResult(\n  1292→        SlangInt entryPointIndex,\n  1293→        SlangInt targetIndex,\n  1294→        slang::ICompileResult** outCompileResult,\n  1295→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1296→    {\n  1297→        return Super::getEntryPointCompileResult(\n  1298→            entryPointIndex,\n  1299→            targetIndex,\n  1300→            outCompileResult,\n  1301→            outDiagnostics);\n  1302→    }\n  1303→\n  1304→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCompileResult(\n  1305→        SlangInt targetIndex,\n  1306→        slang::ICompileResult** outCompileResult,\n  1307→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1308→    {\n  1309→        return Super::getTargetCompileResult(targetIndex, outCompileResult, outDiagnostics);\n  1310→    }\n  1311→\n  1312→    SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n  1313→        SlangInt entryPointIndex,\n  1314→        SlangInt targetIndex,\n  1315→        ISlangMutableFileSystem** outFileSystem) SLANG_OVERRIDE\n  1316→    {\n  1317→        return Super::getResultAsFileSystem(entryPointIndex, targetIndex, outFileSystem);\n  1318→    }\n  1319→\n  1320→    SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n  1321→        slang::SpecializationArg const* specializationArgs,\n  1322→        SlangInt specializationArgCount,\n  1323→        slang::IComponentType** outSpecializedComponentType,\n  1324→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1325→    {\n  1326→        return Super::specialize(\n  1327→            specializationArgs,\n  1328→            specializationArgCount,\n  1329→            outSpecializedComponentType,\n  1330→            outDiagnostics);\n  1331→    }\n  1332→\n  1333→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1334→    renameEntryPoint(const char* newName, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE\n  1335→    {\n  1336→        return Super::renameEntryPoint(newName, outEntryPoint);\n  1337→    }\n  1338→\n  1339→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1340→    link(slang::IComponentType** outLinkedComponentType, ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1341→    {\n  1342→        return Super::link(outLinkedComponentType, outDiagnostics);\n  1343→    }\n  1344→\n  1345→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n  1346→        slang::IComponentType** outLinkedComponentType,\n  1347→        uint32_t count,\n  1348→        slang::CompilerOptionEntry* entries,\n  1349→        ISlangBlob** outDiagnostics) override\n  1350→    {\n  1351→        return Super::linkWithOptions(outLinkedComponentType, count, entries, outDiagnostics);\n  1352→    }\n  1353→\n  1354→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n  1355→        int entryPointIndex,\n  1356→        int targetIndex,\n  1357→        ISlangSharedLibrary** outSharedLibrary,\n  1358→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1359→    {\n  1360→        return Super::getEntryPointHostCallable(\n  1361→            entryPointIndex,\n  1362→            targetIndex,\n  1363→            outSharedLibrary,\n  1364→            outDiagnostics);\n  1365→    }\n  1366→\n  1367→    SLANG_NO_THROW void SLANG_MCALL getEntryPointHash(\n  1368→        SlangInt entryPointIndex,\n  1369→        SlangInt targetIndex,\n  1370→        slang::IBlob** outHash) SLANG_OVERRIDE\n  1371→    {\n  1372→        return Super::getEntryPointHash(entryPointIndex, targetIndex, outHash);\n  1373→    }\n  1374→\n  1375→    virtual void buildHash(DigestBuilder<SHA1>& builder) SLANG_OVERRIDE;\n  1376→\n  1377→    List<Module*> const& getModuleDependencies() SLANG_OVERRIDE;\n  1378→    List<SourceFile*> const& getFileDependencies() SLANG_OVERRIDE;\n  1379→\n  1380→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE { return 0; }\n  1381→\n  1382→    /// Get the existential type parameter at `index`.\n  1383→    SpecializationParam const& getSpecializationParam(Index /*index*/) SLANG_OVERRIDE\n  1384→    {\n  1385→        static SpecializationParam emptyParam;\n  1386→        return emptyParam;\n  1387→    }\n  1388→\n  1389→    Index getRequirementCount() SLANG_OVERRIDE;\n  1390→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE;\n  1391→    Index getEntryPointCount() SLANG_OVERRIDE { return 0; };\n  1392→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE\n  1393→    {\n  1394→        SLANG_UNUSED(index);\n  1395→        return nullptr;\n  1396→    }\n  1397→    String getEntryPointMangledName(Index /*index*/) SLANG_OVERRIDE { return \"\"; }\n  1398→    String getEntryPointNameOverride(Index /*index*/) SLANG_OVERRIDE { return \"\"; }\n  1399→\n  1400→    Index getShaderParamCount() SLANG_OVERRIDE { return 0; }\n  1401→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE\n  1402→    {\n  1403→        SLANG_UNUSED(index);\n  1404→        return ShaderParamInfo();\n  1405→    }\n  1406→\n  1407→    SubtypeWitness* getSubtypeWitness() { return m_subtypeWitness; }\n  1408→    IRModule* getIRModule() { return m_irModule.Ptr(); }\n  1409→\n  1410→protected:\n  1411→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n  1412→        SLANG_OVERRIDE;\n  1413→\n  1414→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n  1415→        SpecializationArg const* args,\n  1416→        Index argCount,\n  1417→        DiagnosticSink* sink) SLANG_OVERRIDE;\n  1418→\n  1419→private:\n  1420→    SubtypeWitness* m_subtypeWitness;\n  1421→    ModuleDependencyList m_moduleDependencyList;\n  1422→    FileDependencyList m_fileDependencyList;\n  1423→    List<RefPtr<Module>> m_requirements;\n  1424→    HashSet<Module*> m_requirementSet;\n  1425→    RefPtr<IRModule> m_irModule;\n  1426→    Int m_conformanceIdOverride;\n  1427→    void addDepedencyFromWitness(SubtypeWitness* witness);\n  1428→};\n  1429→\n  1430→enum class PassThroughMode : SlangPassThroughIntegral\n  1431→{\n  1432→    None = SLANG_PASS_THROUGH_NONE,                  ///< don't pass through: use Slang compiler\n  1433→    Fxc = SLANG_PASS_THROUGH_FXC,                    ///< pass through HLSL to `D3DCompile` API\n  1434→    Dxc = SLANG_PASS_THROUGH_DXC,                    ///< pass through HLSL to `IDxcCompiler` API\n  1435→    Glslang = SLANG_PASS_THROUGH_GLSLANG,            ///< pass through GLSL to `glslang` library\n  1436→    SpirvDis = SLANG_PASS_THROUGH_SPIRV_DIS,         ///< pass through spirv-dis\n  1437→    Clang = SLANG_PASS_THROUGH_CLANG,                ///< Pass through clang compiler\n  1438→    VisualStudio = SLANG_PASS_THROUGH_VISUAL_STUDIO, ///< Visual studio compiler\n  1439→    Gcc = SLANG_PASS_THROUGH_GCC,                    ///< Gcc compiler\n  1440→    GenericCCpp = SLANG_PASS_THROUGH_GENERIC_C_CPP,  ///< Generic C/C++ compiler\n  1441→    NVRTC = SLANG_PASS_THROUGH_NVRTC,                ///< NVRTC CUDA compiler\n  1442→    LLVM = SLANG_PASS_THROUGH_LLVM,                  ///< LLVM 'compiler'\n  1443→    SpirvOpt = SLANG_PASS_THROUGH_SPIRV_OPT,         ///< pass thorugh spirv to spirv-opt\n  1444→    MetalC = SLANG_PASS_THROUGH_METAL,\n  1445→    Tint = SLANG_PASS_THROUGH_TINT,            ///< pass through spirv to Tint API\n  1446→    SpirvLink = SLANG_PASS_THROUGH_SPIRV_LINK, ///< pass through spirv to spirv-link\n  1447→    CountOf = SLANG_PASS_THROUGH_COUNT_OF,\n  1448→};\n  1449→void printDiagnosticArg(StringBuilder& sb, PassThroughMode val);\n  1450→\n  1451→class SourceFile;\n  1452→\n  1453→/// A module of code that has been compiled through the front-end\n  1454→///\n  1455→/// A module comprises all the code from one translation unit (which\n  1456→/// may span multiple Slang source files), and provides access\n  1457→/// to both the AST and IR representations of that code.\n  1458→///\n  1459→class Module : public ComponentType, public slang::IModule\n  1460→{\n  1461→    typedef ComponentType Super;\n  1462→\n  1463→public:\n  1464→    SLANG_REF_OBJECT_IUNKNOWN_ALL\n  1465→\n  1466→    ISlangUnknown* getInterface(const Guid& guid);\n  1467→\n  1468→\n  1469→    // Forward `IComponentType` methods\n  1470→\n  1471→    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n  1472→    {\n  1473→        return Super::getSession();\n  1474→    }\n  1475→\n  1476→    SLANG_NO_THROW slang::ProgramLayout* SLANG_MCALL\n  1477→    getLayout(SlangInt targetIndex, slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1478→    {\n  1479→        return Super::getLayout(targetIndex, outDiagnostics);\n  1480→    }\n  1481→\n  1482→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n  1483→        SlangInt entryPointIndex,\n  1484→        SlangInt targetIndex,\n  1485→        slang::IBlob** outCode,\n  1486→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1487→    {\n  1488→        return Super::getEntryPointCode(entryPointIndex, targetIndex, outCode, outDiagnostics);\n  1489→    }\n  1490→\n  1491→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCode(\n  1492→        SlangInt targetIndex,\n  1493→        slang::IBlob** outCode,\n  1494→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1495→    {\n  1496→        return Super::getTargetCode(targetIndex, outCode, outDiagnostics);\n  1497→    }\n  1498→\n  1499→    SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n  1500→        SlangInt entryPointIndex,\n  1501→        SlangInt targetIndex,\n  1502→        ISlangMutableFileSystem** outFileSystem) SLANG_OVERRIDE\n  1503→    {\n  1504→        return Super::getResultAsFileSystem(entryPointIndex, targetIndex, outFileSystem);\n  1505→    }\n  1506→\n  1507→    SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n  1508→        slang::SpecializationArg const* specializationArgs,\n  1509→        SlangInt specializationArgCount,\n  1510→        slang::IComponentType** outSpecializedComponentType,\n  1511→        ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1512→    {\n  1513→        return Super::specialize(\n  1514→            specializationArgs,\n  1515→            specializationArgCount,\n  1516→            outSpecializedComponentType,\n  1517→            outDiagnostics);\n  1518→    }\n  1519→\n  1520→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1521→    renameEntryPoint(const char* newName, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE\n  1522→    {\n  1523→        return Super::renameEntryPoint(newName, outEntryPoint);\n  1524→    }\n  1525→\n  1526→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1527→    link(slang::IComponentType** outLinkedComponentType, ISlangBlob** outDiagnostics) SLANG_OVERRIDE\n  1528→    {\n  1529→        return Super::link(outLinkedComponentType, outDiagnostics);\n  1530→    }\n  1531→\n  1532→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n  1533→        int entryPointIndex,\n  1534→        int targetIndex,\n  1535→        ISlangSharedLibrary** outSharedLibrary,\n  1536→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1537→    {\n  1538→        return Super::getEntryPointHostCallable(\n  1539→            entryPointIndex,\n  1540→            targetIndex,\n  1541→            outSharedLibrary,\n  1542→            outDiagnostics);\n  1543→    }\n  1544→\n  1545→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  1546→    findEntryPointByName(char const* name, slang::IEntryPoint** outEntryPoint) SLANG_OVERRIDE\n  1547→    {\n  1548→        if (outEntryPoint == nullptr)\n  1549→        {\n  1550→            return SLANG_E_INVALID_ARG;\n  1551→        }\n  1552→        SLANG_AST_BUILDER_RAII(m_astBuilder);\n  1553→        ComPtr<slang::IEntryPoint> entryPoint(findEntryPointByName(UnownedStringSlice(name)));\n  1554→        if ((!entryPoint))\n  1555→            return SLANG_FAIL;\n  1556→\n  1557→        *outEntryPoint = entryPoint.detach();\n  1558→        return SLANG_OK;\n  1559→    }\n  1560→\n  1561→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL findAndCheckEntryPoint(\n  1562→        char const* name,\n  1563→        SlangStage stage,\n  1564→        slang::IEntryPoint** outEntryPoint,\n  1565→        ISlangBlob** outDiagnostics) override\n  1566→    {\n  1567→        if (outEntryPoint == nullptr)\n  1568→        {\n  1569→            return SLANG_E_INVALID_ARG;\n  1570→        }\n  1571→        ComPtr<slang::IEntryPoint> entryPoint(\n  1572→            findAndCheckEntryPoint(UnownedStringSlice(name), stage, outDiagnostics));\n  1573→        if ((!entryPoint))\n  1574→            return SLANG_FAIL;\n  1575→\n  1576→        *outEntryPoint = entryPoint.detach();\n  1577→        return SLANG_OK;\n  1578→    }\n  1579→\n  1580→    virtual SLANG_NO_THROW SlangInt32 SLANG_MCALL getDefinedEntryPointCount() override\n  1581→    {\n  1582→        return (SlangInt32)m_entryPoints.getCount();\n  1583→    }\n  1584→\n  1585→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  1586→    getDefinedEntryPoint(SlangInt32 index, slang::IEntryPoint** outEntryPoint) override\n  1587→    {\n  1588→        if (index < 0 || index >= m_entryPoints.getCount())\n  1589→            return SLANG_E_INVALID_ARG;\n  1590→\n  1591→        if (outEntryPoint == nullptr)\n  1592→        {\n  1593→            return SLANG_E_INVALID_ARG;\n  1594→        }\n  1595→\n  1596→        ComPtr<slang::IEntryPoint> entryPoint(m_entryPoints[index].Ptr());\n  1597→        *outEntryPoint = entryPoint.detach();\n  1598→        return SLANG_OK;\n  1599→    }\n  1600→\n  1601→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n  1602→        slang::IComponentType** outLinkedComponentType,\n  1603→        uint32_t count,\n  1604→        slang::CompilerOptionEntry* entries,\n  1605→        ISlangBlob** outDiagnostics) override\n  1606→    {\n  1607→        return Super::linkWithOptions(outLinkedComponentType, count, entries, outDiagnostics);\n  1608→    }\n  1609→    //\n  1610→\n  1611→    SLANG_NO_THROW void SLANG_MCALL getEntryPointHash(\n  1612→        SlangInt entryPointIndex,\n  1613→        SlangInt targetIndex,\n  1614→        slang::IBlob** outHash) SLANG_OVERRIDE\n  1615→    {\n  1616→        return Super::getEntryPointHash(entryPointIndex, targetIndex, outHash);\n  1617→    }\n  1618→\n  1619→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointMetadata(\n  1620→        SlangInt entryPointIndex,\n  1621→        SlangInt targetIndex,\n  1622→        slang::IMetadata** outMetadata,\n  1623→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1624→    {\n  1625→        return Super::getEntryPointMetadata(\n  1626→            entryPointIndex,\n  1627→            targetIndex,\n  1628→            outMetadata,\n  1629→            outDiagnostics);\n  1630→    }\n  1631→\n  1632→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetMetadata(\n  1633→        SlangInt targetIndex,\n  1634→        slang::IMetadata** outMetadata,\n  1635→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1636→    {\n  1637→        return Super::getTargetMetadata(targetIndex, outMetadata, outDiagnostics);\n  1638→    }\n  1639→\n  1640→    SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCompileResult(\n  1641→        SlangInt entryPointIndex,\n  1642→        SlangInt targetIndex,\n  1643→        slang::ICompileResult** outCompileResult,\n  1644→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1645→    {\n  1646→        return Super::getEntryPointCompileResult(\n  1647→            entryPointIndex,\n  1648→            targetIndex,\n  1649→            outCompileResult,\n  1650→            outDiagnostics);\n  1651→    }\n  1652→\n  1653→    SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCompileResult(\n  1654→        SlangInt targetIndex,\n  1655→        slang::ICompileResult** outCompileResult,\n  1656→        slang::IBlob** outDiagnostics) SLANG_OVERRIDE\n  1657→    {\n  1658→        return Super::getTargetCompileResult(targetIndex, outCompileResult, outDiagnostics);\n  1659→    }\n  1660→\n  1661→    /// Get a serialized representation of the checked module.\n  1662→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  1663→    serialize(ISlangBlob** outSerializedBlob) override;\n  1664→\n  1665→    /// Write the serialized representation of this module to a file.\n  1666→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL writeToFile(char const* fileName) override;\n  1667→\n  1668→    /// Get the name of the module.\n  1669→    virtual SLANG_NO_THROW const char* SLANG_MCALL getName() override;\n  1670→\n  1671→    /// Get the path of the module.\n  1672→    virtual SLANG_NO_THROW const char* SLANG_MCALL getFilePath() override;\n  1673→\n  1674→    /// Get the unique identity of the module.\n  1675→    virtual SLANG_NO_THROW const char* SLANG_MCALL getUniqueIdentity() override;\n  1676→\n  1677→    /// Get the number of dependency files that this module depends on.\n  1678→    /// This includes both the explicit source files, as well as any\n  1679→    /// additional files that were transitively referenced (e.g., via\n  1680→    /// a `#include` directive).\n  1681→    virtual SLANG_NO_THROW SlangInt32 SLANG_MCALL getDependencyFileCount() override;\n  1682→\n  1683→    /// Get the path to a file this module depends on.\n  1684→    virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(SlangInt32 index) override;\n  1685→\n  1686→\n  1687→    // IModulePrecompileService_Experimental\n  1688→    /// Precompile TU to target language\n  1689→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  1690→    precompileForTarget(SlangCompileTarget target, slang::IBlob** outDiagnostics) override;\n  1691→\n  1692→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getPrecompiledTargetCode(\n  1693→        SlangCompileTarget target,\n  1694→        slang::IBlob** outCode,\n  1695→        slang::IBlob** outDiagnostics = nullptr) override;\n  1696→\n  1697→    virtual SLANG_NO_THROW SlangInt SLANG_MCALL getModuleDependencyCount() SLANG_OVERRIDE;\n  1698→\n  1699→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getModuleDependency(\n  1700→        SlangInt dependencyIndex,\n  1701→        slang::IModule** outModule,\n  1702→        slang::IBlob** outDiagnostics = nullptr) SLANG_OVERRIDE;\n  1703→\n  1704→    virtual void buildHash(DigestBuilder<SHA1>& builder) SLANG_OVERRIDE;\n  1705→\n  1706→    virtual SLANG_NO_THROW slang::DeclReflection* SLANG_MCALL getModuleReflection() SLANG_OVERRIDE;\n  1707→\n  1708→    void setDigest(SHA1::Digest const& digest) { m_digest = digest; }\n  1709→    SHA1::Digest computeDigest();\n  1710→\n  1711→    /// Create a module (initially empty).\n  1712→    Module(Linkage* linkage, ASTBuilder* astBuilder = nullptr);\n  1713→\n  1714→    /// Get the AST for the module (if it has been parsed)\n  1715→    ModuleDecl* getModuleDecl() { return m_moduleDecl; }\n  1716→\n  1717→    /// The the IR for the module (if it has been generated)\n  1718→    IRModule* getIRModule() { return m_irModule; }\n  1719→\n  1720→    /// Get the list of other modules this module depends on\n  1721→    List<Module*> const& getModuleDependencyList()\n  1722→    {\n  1723→        return m_moduleDependencyList.getModuleList();\n  1724→    }\n  1725→\n  1726→    /// Get the list of files this module depends on\n  1727→    List<SourceFile*> const& getFileDependencyList() { return m_fileDependencyList.getFileList(); }\n  1728→\n  1729→    /// Register a module that this module depends on\n  1730→    void addModuleDependency(Module* module);\n  1731→\n  1732→    /// Register a source file that this module depends on\n  1733→    void addFileDependency(SourceFile* sourceFile);\n  1734→\n  1735→    void clearFileDependency() { m_fileDependencyList.clear(); }\n  1736→    /// Set the AST for this module.\n  1737→    ///\n  1738→    /// This should only be called once, during creation of the module.\n  1739→    ///\n  1740→    void setModuleDecl(ModuleDecl* moduleDecl); // { m_moduleDecl = moduleDecl; }\n  1741→\n  1742→    void setName(String name);\n  1743→    void setName(Name* name) { m_name = name; }\n  1744→    Name* getNameObj() { return m_name; }\n  1745→\n  1746→    void setPathInfo(PathInfo pathInfo) { m_pathInfo = pathInfo; }\n  1747→\n  1748→    /// Set the IR for this module.\n  1749→    ///\n  1750→    /// This should only be called once, during creation of the module.\n  1751→    ///\n  1752→    void setIRModule(IRModule* irModule) { m_irModule = irModule; }\n  1753→\n  1754→    Index getEntryPointCount() SLANG_OVERRIDE { return 0; }\n  1755→    RefPtr<EntryPoint> getEntryPoint(Index index) SLANG_OVERRIDE\n  1756→    {\n  1757→        SLANG_UNUSED(index);\n  1758→        return nullptr;\n  1759→    }\n  1760→    String getEntryPointMangledName(Index index) SLANG_OVERRIDE\n  1761→    {\n  1762→        SLANG_UNUSED(index);\n  1763→        return String();\n  1764→    }\n  1765→    String getEntryPointNameOverride(Index index) SLANG_OVERRIDE\n  1766→    {\n  1767→        SLANG_UNUSED(index);\n  1768→        return String();\n  1769→    }\n  1770→\n  1771→    Index getShaderParamCount() SLANG_OVERRIDE { return m_shaderParams.getCount(); }\n  1772→    ShaderParamInfo getShaderParam(Index index) SLANG_OVERRIDE { return m_shaderParams[index]; }\n  1773→\n  1774→    SLANG_NO_THROW Index SLANG_MCALL getSpecializationParamCount() SLANG_OVERRIDE\n  1775→    {\n  1776→        return m_specializationParams.getCount();\n  1777→    }\n  1778→    SpecializationParam const& getSpecializationParam(Index index) SLANG_OVERRIDE\n  1779→    {\n  1780→        return m_specializationParams[index];\n  1781→    }\n  1782→\n  1783→    Index getRequirementCount() SLANG_OVERRIDE;\n  1784→    RefPtr<ComponentType> getRequirement(Index index) SLANG_OVERRIDE;\n  1785→\n  1786→    List<Module*> const& getModuleDependencies() SLANG_OVERRIDE\n  1787→    {\n  1788→        return m_moduleDependencyList.getModuleList();\n  1789→    }\n  1790→    List<SourceFile*> const& getFileDependencies() SLANG_OVERRIDE\n  1791→    {\n  1792→        return m_fileDependencyList.getFileList();\n  1793→    }\n  1794→\n  1795→    /// Given a mangled name finds the exported NodeBase associated with this module.\n  1796→    /// If not found returns nullptr.\n  1797→    Decl* findExportedDeclByMangledName(const UnownedStringSlice& mangledName);\n  1798→\n  1799→    /// Ensure that the any accelerator(s) used for `findExportedDeclByMangledName`\n  1800→    /// have already been built.\n  1801→    ///\n  1802→    void ensureExportLookupAcceleratorBuilt();\n  1803→\n  1804→    Count getExportedDeclCount();\n  1805→    Decl* getExportedDecl(Index index);\n  1806→    UnownedStringSlice getExportedDeclMangledName(Index index);\n  1807→\n  1808→    /// Get the ASTBuilder\n  1809→    ASTBuilder* getASTBuilder() { return m_astBuilder; }\n  1810→\n  1811→    /// Collect information on the shader parameters of the module.\n  1812→    ///\n  1813→    /// This method should only be called once, after the core\n  1814→    /// structured of the module (its AST and IR) have been created,\n  1815→    /// and before any of the `ComponentType` APIs are used.\n  1816→    ///\n  1817→    /// TODO: We might eventually consider a non-stateful approach\n  1818→    /// to constructing a `Module`.\n  1819→    ///\n  1820→    void _collectShaderParams();\n  1821→\n  1822→    void _discoverEntryPoints(DiagnosticSink* sink, const List<RefPtr<TargetRequest>>& targets);\n  1823→    void _discoverEntryPointsImpl(\n  1824→        ContainerDecl* containerDecl,\n  1825→        DiagnosticSink* sink,\n  1826→        const List<RefPtr<TargetRequest>>& targets);\n  1827→\n  1828→\n  1829→    class ModuleSpecializationInfo : public SpecializationInfo\n  1830→    {\n  1831→    public:\n  1832→        struct GenericArgInfo\n  1833→        {\n  1834→            Decl* paramDecl = nullptr;\n  1835→            Val* argVal = nullptr;\n  1836→        };\n  1837→\n  1838→        List<GenericArgInfo> genericArgs;\n  1839→        List<ExpandedSpecializationArg> existentialArgs;\n  1840→    };\n  1841→\n  1842→    RefPtr<EntryPoint> findEntryPointByName(UnownedStringSlice const& name);\n  1843→    RefPtr<EntryPoint> findAndCheckEntryPoint(\n  1844→        UnownedStringSlice const& name,\n  1845→        SlangStage stage,\n  1846→        ISlangBlob** outDiagnostics);\n  1847→\n  1848→    List<RefPtr<EntryPoint>>& getEntryPoints() { return m_entryPoints; }\n  1849→    void _addEntryPoint(EntryPoint* entryPoint);\n  1850→    void _processFindDeclsExportSymbolsRec(Decl* decl);\n  1851→\n  1852→    // Gets the files that has been included into the module.\n  1853→    Dictionary<SourceFile*, FileDecl*>& getIncludedSourceFileMap()\n  1854→    {\n  1855→        return m_mapSourceFileToFileDecl;\n  1856→    }\n  1857→\n  1858→protected:\n  1859→    void acceptVisitor(ComponentTypeVisitor* visitor, SpecializationInfo* specializationInfo)\n  1860→        SLANG_OVERRIDE;\n  1861→\n  1862→    RefPtr<SpecializationInfo> _validateSpecializationArgsImpl(\n  1863→        SpecializationArg const* args,\n  1864→        Index argCount,\n  1865→        DiagnosticSink* sink) SLANG_OVERRIDE;\n  1866→\n  1867→private:\n  1868→    Name* m_name = nullptr;\n  1869→    PathInfo m_pathInfo;\n  1870→\n  1871→    // The AST for the module\n  1872→    ModuleDecl* m_moduleDecl = nullptr;\n  1873→\n  1874→    // The IR for the module\n  1875→    RefPtr<IRModule> m_irModule = nullptr;\n  1876→\n  1877→    List<ShaderParamInfo> m_shaderParams;\n  1878→    SpecializationParams m_specializationParams;\n  1879→\n  1880→    List<Module*> m_requirements;\n  1881→\n  1882→    // A digest that uniquely identifies the contents of the module.\n  1883→    SHA1::Digest m_digest;\n  1884→\n  1885→    // List of modules this module depends on\n  1886→    ModuleDependencyList m_moduleDependencyList;\n  1887→\n  1888→    // List of source files this module depends on\n  1889→    FileDependencyList m_fileDependencyList;\n  1890→\n  1891→    // Entry points that were defined in this module\n  1892→    //\n  1893→    // Note: the entry point defined in the module are *not*\n  1894→    // part of the memory image/layout of the module when\n  1895→    // it is considered as an IComponentType. This can be\n  1896→    // a bit confusing, but if all the entry points in the\n  1897→    // module were automatically linked into the component\n  1898→    // type, we'd need a way to access just the global\n  1899→    // scope of the module without the entry points, in\n  1900→    // case we wanted to link a single entry point against\n  1901→    // the global scope. The `Module` type provides exactly\n  1902→    // that \"module without its entry points\" unit of\n  1903→    // granularity for linking.\n  1904→    //\n  1905→    // This list only exists for lookup purposes, so that\n  1906→    // the user can find an existing entry-point function\n  1907→    // that was defined as part of the module.\n  1908→    //\n  1909→    List<RefPtr<EntryPoint>> m_entryPoints;\n  1910→\n  1911→    // The builder that owns all of the AST nodes from parsing the source of\n  1912→    // this module.\n  1913→    RefPtr<ASTBuilder> m_astBuilder;\n  1914→\n  1915→    // Holds map of exported mangled names to symbols. m_mangledExportPool maps names to indices,\n  1916→    // and m_mangledExportSymbols holds the NodeBase* values for each index.\n  1917→    StringSlicePool m_mangledExportPool;\n  1918→    List<Decl*> m_mangledExportSymbols;\n  1919→\n  1920→    // Source files that have been pulled into the module with `__include`.\n  1921→    Dictionary<SourceFile*, FileDecl*> m_mapSourceFileToFileDecl;\n  1922→\n  1923→public:\n  1924→    SLANG_NO_THROW SlangResult SLANG_MCALL disassemble(slang::IBlob** outDisassembledBlob) override\n  1925→    {\n  1926→        if (!outDisassembledBlob)\n  1927→            return SLANG_E_INVALID_ARG;\n  1928→        String disassembly;\n  1929→        this->getIRModule()->getModuleInst()->dump(disassembly);\n  1930→        auto blob = StringUtil::createStringBlob(disassembly);\n  1931→        *outDisassembledBlob = blob.detach();\n  1932→        return SLANG_OK;\n  1933→    }\n  1934→};\n  1935→typedef Module LoadedModule;\n  1936→\n  1937→/// A request for the front-end to compile a translation unit.\n  1938→class TranslationUnitRequest : public RefObject\n  1939→{\n  1940→public:\n  1941→    TranslationUnitRequest(FrontEndCompileRequest* compileRequest);\n  1942→    TranslationUnitRequest(FrontEndCompileRequest* compileRequest, Module* m);\n  1943→\n  1944→    // The parent compile request\n  1945→    FrontEndCompileRequest* compileRequest = nullptr;\n  1946→\n  1947→    // The language in which the source file(s)\n  1948→    // are assumed to be written\n  1949→    SourceLanguage sourceLanguage = SourceLanguage::Unknown;\n  1950→\n  1951→    /// Makes any source artifact available as a SourceFile.\n  1952→    /// If successful any of the source artifacts will be represented by the same index\n  1953→    /// of sourceArtifacts\n  1954→    SlangResult requireSourceFiles();\n  1955→\n  1956→    /// Get the source files.\n  1957→    /// Since lazily evaluated requires calling requireSourceFiles to know it's in sync\n  1958→    /// with sourceArtifacts.\n  1959→    List<SourceFile*> const& getSourceFiles();\n  1960→\n  1961→    /// Get the source artifacts associated\n  1962→    const List<ComPtr<IArtifact>>& getSourceArtifacts() const { return m_sourceArtifacts; }\n  1963→\n  1964→    /// Clear all of the source\n  1965→    void clearSource()\n  1966→    {\n  1967→        m_sourceArtifacts.clear();\n  1968→        m_sourceFiles.clear();\n  1969→        m_includedFileSet.clear();\n  1970→    }\n  1971→\n  1972→    /// Add a source artifact\n  1973→    void addSourceArtifact(IArtifact* sourceArtifact);\n  1974→\n  1975→    /// Add both the artifact and the sourceFile.\n  1976→    void addSource(IArtifact* sourceArtifact, SourceFile* sourceFile);\n  1977→\n  1978→    void addIncludedSourceFileIfNotExist(SourceFile* sourceFile);\n  1979→\n  1980→    // The entry points associated with this translation unit\n  1981→    List<RefPtr<EntryPoint>> const& getEntryPoints() { return module->getEntryPoints(); }\n  1982→\n  1983→    void _addEntryPoint(EntryPoint* entryPoint) { module->_addEntryPoint(entryPoint); }\n  1984→\n  1985→    // Preprocessor definitions to use for this translation unit only\n  1986→    // (whereas the ones on `compileRequest` will be shared)\n  1987→    Dictionary<String, String> preprocessorDefinitions;\n  1988→\n  1989→    /// The name that will be used for the module this translation unit produces.\n  1990→    Name* moduleName = nullptr;\n  1991→\n  1992→    /// Result of compiling this translation unit (a module)\n  1993→    RefPtr<Module> module;\n  1994→\n  1995→    bool isChecked = false;\n  1996→\n  1997→    Module* getModule() { return module; }\n  1998→    ModuleDecl* getModuleDecl() { return module->getModuleDecl(); }\n  1999→\n  2000→    Session* getSession();\n  2001→    NamePool* getNamePool();\n  2002→    SourceManager* getSourceManager();\n  2003→\n  2004→    Scope* getLanguageScope();\n  2005→\n  2006→    Dictionary<String, String> getCombinedPreprocessorDefinitions();\n  2007→\n  2008→    void setModuleName(Name* name)\n  2009→    {\n  2010→        moduleName = name;\n  2011→        if (module)\n  2012→            module->setName(name);\n  2013→    }\n  2014→\n  2015→protected:\n  2016→    void _addSourceFile(SourceFile* sourceFile);\n  2017→    /* Given an artifact, find a PathInfo.\n  2018→    If no PathInfo can be found will return an unknown PathInfo */\n  2019→    PathInfo _findSourcePathInfo(IArtifact* artifact);\n  2020→\n  2021→    List<ComPtr<IArtifact>> m_sourceArtifacts;\n  2022→    // The source file(s) that will be compiled to form this translation unit\n  2023→    //\n  2024→    // Usually, for HLSL or GLSL there will be only one file.\n  2025→    // NOTE! This member is generated lazily from m_sourceArtifacts\n  2026→    // it is *necessary* to call requireSourceFiles to ensure it's in sync.\n  2027→    List<SourceFile*> m_sourceFiles;\n  2028→\n  2029→    // Track all the included source files added in m_sourceFiles\n  2030→    HashSet<SourceFile*> m_includedFileSet;\n  2031→};\n  2032→\n  2033→enum class FloatingPointMode : SlangFloatingPointModeIntegral\n  2034→{\n  2035→    Default = SLANG_FLOATING_POINT_MODE_DEFAULT,\n  2036→    Fast = SLANG_FLOATING_POINT_MODE_FAST,\n  2037→    Precise = SLANG_FLOATING_POINT_MODE_PRECISE,\n  2038→};\n  2039→\n  2040→enum class FloatingPointDenormalMode : SlangFpDenormalModeIntegral\n  2041→{\n  2042→    Any = SLANG_FP_DENORM_MODE_ANY,\n  2043→    Preserve = SLANG_FP_DENORM_MODE_PRESERVE,\n  2044→    FlushToZero = SLANG_FP_DENORM_MODE_FTZ,\n  2045→};\n  2046→\n  2047→enum class WriterChannel : SlangWriterChannelIntegral\n  2048→{\n  2049→    Diagnostic = SLANG_WRITER_CHANNEL_DIAGNOSTIC,\n  2050→    StdOutput = SLANG_WRITER_CHANNEL_STD_OUTPUT,\n  2051→    StdError = SLANG_WRITER_CHANNEL_STD_ERROR,\n  2052→    CountOf = SLANG_WRITER_CHANNEL_COUNT_OF,\n  2053→};\n  2054→\n  2055→enum class WriterMode : SlangWriterModeIntegral\n  2056→{\n  2057→    Text = SLANG_WRITER_MODE_TEXT,\n  2058→    Binary = SLANG_WRITER_MODE_BINARY,\n  2059→};\n  2060→\n  2061→class TargetRequest;\n  2062→\n  2063→/// Are we generating code for a D3D API?\n  2064→bool isD3DTarget(TargetRequest* targetReq);\n  2065→\n  2066→// Are we generating code for Metal?\n  2067→bool isMetalTarget(TargetRequest* targetReq);\n  2068→\n  2069→/// Are we generating code for a Khronos API (OpenGL or Vulkan)?\n  2070→bool isKhronosTarget(TargetRequest* targetReq);\n  2071→bool isKhronosTarget(CodeGenTarget target);\n  2072→\n  2073→/// Are we generating code for a CUDA API (CUDA / OptiX)?\n  2074→bool isCUDATarget(TargetRequest* targetReq);\n  2075→\n  2076→// Are we generating code for a CPU target\n  2077→bool isCPUTarget(TargetRequest* targetReq);\n  2078→\n  2079→/// Are we generating code for the WebGPU API?\n  2080→bool isWGPUTarget(TargetRequest* targetReq);\n  2081→bool isWGPUTarget(CodeGenTarget target);\n  2082→\n  2083→/// A request to generate output in some target format.\n  2084→class TargetRequest : public RefObject\n  2085→{\n  2086→public:\n  2087→    TargetRequest(Linkage* linkage, CodeGenTarget format);\n  2088→\n  2089→    TargetRequest(const TargetRequest& other);\n  2090→\n  2091→    Linkage* getLinkage() { return linkage; }\n  2092→\n  2093→    Session* getSession();\n  2094→\n  2095→    CodeGenTarget getTarget()\n  2096→    {\n  2097→        return optionSet.getEnumOption<CodeGenTarget>(CompilerOptionName::Target);\n  2098→    }\n  2099→\n  2100→    // TypeLayouts created on the fly by reflection API\n  2101→    struct TypeLayoutKey\n  2102→    {\n  2103→        Type* type;\n  2104→        slang::LayoutRules rules;\n  2105→        HashCode getHashCode() const\n  2106→        {\n  2107→            Hasher hasher;\n  2108→            hasher.hashValue(type);\n  2109→            hasher.hashValue(rules);\n  2110→            return hasher.getResult();\n  2111→        }\n  2112→        bool operator==(TypeLayoutKey other) const\n  2113→        {\n  2114→            return type == other.type && rules == other.rules;\n  2115→        }\n  2116→    };\n  2117→    Dictionary<TypeLayoutKey, RefPtr<TypeLayout>> typeLayouts;\n  2118→\n  2119→    Dictionary<TypeLayoutKey, RefPtr<TypeLayout>>& getTypeLayouts() { return typeLayouts; }\n  2120→\n  2121→    TypeLayout* getTypeLayout(Type* type, slang::LayoutRules rules);\n  2122→\n  2123→    CompilerOptionSet& getOptionSet() { return optionSet; }\n  2124→\n  2125→    CapabilitySet getTargetCaps();\n  2126→\n  2127→    void setTargetCaps(CapabilitySet capSet);\n  2128→\n  2129→    HLSLToVulkanLayoutOptions* getHLSLToVulkanLayoutOptions();\n  2130→\n  2131→private:\n  2132→    Linkage* linkage = nullptr;\n  2133→    CompilerOptionSet optionSet;\n  2134→    CapabilitySet cookedCapabilities;\n  2135→    RefPtr<HLSLToVulkanLayoutOptions> hlslToVulkanOptions;\n  2136→};\n  2137→\n  2138→/// Given a target request returns which (if any) intermediate source language is required\n  2139→/// to produce it.\n  2140→///\n  2141→/// If no intermediate source language is required, will return SourceLanguage::Unknown\n  2142→SourceLanguage getIntermediateSourceLanguageForTarget(TargetProgram* req);\n  2143→\n  2144→/// Are resource types \"bindless\" (implemented as ordinary data) on the given `target`?\n  2145→bool areResourceTypesBindlessOnTarget(TargetRequest* target);\n  2146→\n  2147→// Compute the \"effective\" profile to use when outputting the given entry point\n  2148→// for the chosen code-generation target.\n  2149→//\n  2150→// The stage of the effective profile will always come from the entry point, while\n  2151→// the profile version (aka \"shader model\") will be computed as follows:\n  2152→//\n  2153→// - If the entry point and target belong to the same profile family, then take\n  2154→//   the latest version between the two (e.g., if the entry point specified `ps_5_1`\n  2155→//   and the target specifies `sm_5_0` then use `sm_5_1` as the version).\n  2156→//\n  2157→// - If the entry point and target disagree on the profile family, always use the\n  2158→//   profile family and version from the target.\n  2159→//\n  2160→Profile getEffectiveProfile(EntryPoint* entryPoint, TargetRequest* target);\n  2161→\n  2162→\n  2163→/// Given a target returns the required downstream compiler\n  2164→PassThroughMode getDownstreamCompilerRequiredForTarget(CodeGenTarget target);\n  2165→/// Given a target returns a downstream compiler the prelude should be taken from.\n  2166→SourceLanguage getDefaultSourceLanguageForDownstreamCompiler(PassThroughMode compiler);\n  2167→\n  2168→/// Get the build tag string\n  2169→const char* getBuildTagString();\n  2170→\n  2171→struct TypeCheckingCache;\n  2172→\n  2173→struct ContainerTypeKey\n  2174→{\n  2175→    slang::TypeReflection* elementType;\n  2176→    slang::ContainerType containerType;\n  2177→    bool operator==(ContainerTypeKey other) const\n  2178→    {\n  2179→        return elementType == other.elementType && containerType == other.containerType;\n  2180→    }\n  2181→    Slang::HashCode getHashCode() const\n  2182→    {\n  2183→        return Slang::combineHash(\n  2184→            Slang::getHashCode(elementType),\n  2185→            Slang::getHashCode(containerType));\n  2186→    }\n  2187→};\n  2188→\n  2189→/// A dictionary of modules to be considered when resolving `import`s,\n  2190→/// beyond those that would normally be found through a `Linkage`.\n  2191→///\n  2192→/// Checking of an `import` declaration will bottleneck through\n  2193→/// `Linkage::findOrImportModule`, which would usually just check for\n  2194→/// any module that had been previously loaded into the same `Linkage`\n  2195→/// (e.g., by a call to `Linkage::loadModule()`).\n  2196→///\n  2197→/// In the case where compilation is being done through an\n  2198→/// explicit `FrontEndCompileRequest` or `EndToEndCompileRequest`,\n  2199→/// the modules being compiled by that request do not get added to\n  2200→/// the surrounding `Linkage`.\n  2201→///\n  2202→/// There is a corner case when an explicit compile request has\n  2203→/// multiple `TranslationUnitRequest`s, because the user (reasonably)\n  2204→/// expects that if they compile `A.slang` and `B.slang` as two\n  2205→/// distinct translation units in the same compile request, then\n  2206→/// an `import B` inside of `A.slang` should resolve to reference\n  2207→/// the code of `B.slang`. But because neither `A` nor `B` gets\n  2208→/// added to the `Linkage`, and the `Linkage` is what usually\n  2209→/// determines what is or isn't loaded, that intuition will\n  2210→/// be wrong, without a bit of help.\n  2211→///\n  2212→/// The `LoadedModuleDictionary` is thus filled in by a\n  2213→/// `FrontEndCompileRequest` to collect the modules it is compiling,\n  2214→/// so that they can cross-reference one another (albeit with\n  2215→/// a current implementation restriction that modules in the\n  2216→/// request can only `import` those earlier in the request...).\n  2217→///\n  2218→/// The dictionary then gets passed around between nearly all of\n  2219→/// the operations that deal with loading modules, to make sure\n  2220→/// that they can detect a previously loaded module.\n  2221→///\n  2222→typedef Dictionary<Name*, Module*> LoadedModuleDictionary;\n  2223→\n  2224→enum ModuleBlobType\n  2225→{\n  2226→    Source,\n  2227→    IR\n  2228→};\n  2229→\n  2230→/// A context for loading and re-using code modules.\n  2231→class Linkage : public RefObject, public slang::ISession\n  2232→{\n  2233→public:\n  2234→    SLANG_REF_OBJECT_IUNKNOWN_ALL\n  2235→\n  2236→    CompilerOptionSet m_optionSet;\n  2237→\n  2238→    ISlangUnknown* getInterface(const Guid& guid);\n  2239→\n  2240→    SLANG_NO_THROW slang::IGlobalSession* SLANG_MCALL getGlobalSession() override;\n  2241→    SLANG_NO_THROW slang::IModule* SLANG_MCALL\n  2242→    loadModule(const char* moduleName, slang::IBlob** outDiagnostics = nullptr) override;\n  2243→    slang::IModule* loadModuleFromBlob(\n  2244→        const char* moduleName,\n  2245→        const char* path,\n  2246→        slang::IBlob* source,\n  2247→        ModuleBlobType blobType,\n  2248→        slang::IBlob** outDiagnostics = nullptr);\n  2249→    SLANG_NO_THROW slang::IModule* SLANG_MCALL loadModuleFromIRBlob(\n  2250→        const char* moduleName,\n  2251→        const char* path,\n  2252→        slang::IBlob* source,\n  2253→        slang::IBlob** outDiagnostics = nullptr) override;\n  2254→    SLANG_NO_THROW SlangResult SLANG_MCALL loadModuleInfoFromIRBlob(\n  2255→        slang::IBlob* source,\n  2256→        SlangInt& outModuleVersion,\n  2257→        const char*& outModuleCompilerVersion,\n  2258→        const char*& outModuleName) override;\n  2259→    SLANG_NO_THROW slang::IModule* SLANG_MCALL loadModuleFromSource(\n  2260→        const char* moduleName,\n  2261→        const char* path,\n  2262→        slang::IBlob* source,\n  2263→        slang::IBlob** outDiagnostics = nullptr) override;\n  2264→    SLANG_NO_THROW slang::IModule* SLANG_MCALL loadModuleFromSourceString(\n  2265→        const char* moduleName,\n  2266→        const char* path,\n  2267→        const char* string,\n  2268→        slang::IBlob** outDiagnostics = nullptr) override;\n  2269→    SLANG_NO_THROW SlangResult SLANG_MCALL createCompositeComponentType(\n  2270→        slang::IComponentType* const* componentTypes,\n  2271→        SlangInt componentTypeCount,\n  2272→        slang::IComponentType** outCompositeComponentType,\n  2273→        ISlangBlob** outDiagnostics = nullptr) override;\n  2274→    SLANG_NO_THROW slang::TypeReflection* SLANG_MCALL specializeType(\n  2275→        slang::TypeReflection* type,\n  2276→        slang::SpecializationArg const* specializationArgs,\n  2277→        SlangInt specializationArgCount,\n  2278→        ISlangBlob** outDiagnostics = nullptr) override;\n  2279→    SLANG_NO_THROW slang::TypeLayoutReflection* SLANG_MCALL getTypeLayout(\n  2280→        slang::TypeReflection* type,\n  2281→        SlangInt targetIndex = 0,\n  2282→        slang::LayoutRules rules = slang::LayoutRules::Default,\n  2283→        ISlangBlob** outDiagnostics = nullptr) override;\n  2284→    SLANG_NO_THROW slang::TypeReflection* SLANG_MCALL getContainerType(\n  2285→        slang::TypeReflection* elementType,\n  2286→        slang::ContainerType containerType,\n  2287→        ISlangBlob** outDiagnostics = nullptr) override;\n  2288→    SLANG_NO_THROW slang::TypeReflection* SLANG_MCALL getDynamicType() override;\n  2289→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  2290→    getTypeRTTIMangledName(slang::TypeReflection* type, ISlangBlob** outNameBlob) override;\n  2291→    SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessMangledName(\n  2292→        slang::TypeReflection* type,\n  2293→        slang::TypeReflection* interfaceType,\n  2294→        ISlangBlob** outNameBlob) override;\n  2295→    SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessSequentialID(\n  2296→        slang::TypeReflection* type,\n  2297→        slang::TypeReflection* interfaceType,\n  2298→        uint32_t* outId) override;\n  2299→    SLANG_NO_THROW SlangResult SLANG_MCALL getDynamicObjectRTTIBytes(\n  2300→        slang::TypeReflection* type,\n  2301→        slang::TypeReflection* interfaceType,\n  2302→        uint32_t* outBytes,\n  2303→        uint32_t bufferSize) override;\n  2304→    SLANG_NO_THROW SlangResult SLANG_MCALL createTypeConformanceComponentType(\n  2305→        slang::TypeReflection* type,\n  2306→        slang::TypeReflection* interfaceType,\n  2307→        slang::ITypeConformance** outConformance,\n  2308→        SlangInt conformanceIdOverride,\n  2309→        ISlangBlob** outDiagnostics) override;\n  2310→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  2311→    createCompileRequest(SlangCompileRequest** outCompileRequest) override;\n  2312→    virtual SLANG_NO_THROW SlangInt SLANG_MCALL getLoadedModuleCount() override;\n  2313→    virtual SLANG_NO_THROW slang::IModule* SLANG_MCALL getLoadedModule(SlangInt index) override;\n  2314→    virtual SLANG_NO_THROW bool SLANG_MCALL\n  2315→    isBinaryModuleUpToDate(const char* modulePath, slang::IBlob* binaryModuleBlob) override;\n  2316→\n  2317→    // Updates the supplied builder with linkage-related information, which includes preprocessor\n  2318→    // defines, the compiler version, and other compiler options. This is then merged with the hash\n  2319→    // produced for the program to produce a key that can be used with the shader cache.\n  2320→    void buildHash(DigestBuilder<SHA1>& builder, SlangInt targetIndex = -1);\n  2321→\n  2322→    void addTarget(slang::TargetDesc const& desc);\n  2323→    SlangResult addSearchPath(char const* path);\n  2324→    SlangResult addPreprocessorDefine(char const* name, char const* value);\n  2325→    SlangResult setMatrixLayoutMode(SlangMatrixLayoutMode mode);\n  2326→    /// Create an initially-empty linkage\n  2327→    Linkage(Session* session, ASTBuilder* astBuilder, Linkage* builtinLinkage);\n  2328→\n  2329→    /// Dtor\n  2330→    ~Linkage();\n  2331→\n  2332→    bool isInLanguageServer()\n  2333→    {\n  2334→        return contentAssistInfo.checkingMode != ContentAssistCheckingMode::None;\n  2335→    }\n  2336→\n  2337→    /// Get the parent session for this linkage\n  2338→    Session* getSessionImpl() { return m_session; }\n  2339→\n  2340→    // Information on the targets we are being asked to\n  2341→    // generate code for.\n  2342→    List<RefPtr<TargetRequest>> targets;\n  2343→\n  2344→    // Directories to search for `#include` files or `import`ed modules\n  2345→    SearchDirectoryList& getSearchDirectories();\n  2346→\n  2347→    // Source manager to help track files loaded\n  2348→    SourceManager m_defaultSourceManager;\n  2349→    SourceManager* m_sourceManager = nullptr;\n  2350→    RefPtr<CommandLineContext> m_cmdLineContext;\n  2351→\n  2352→    // Used to store strings returned by the api as const char*\n  2353→    StringSlicePool m_stringSlicePool;\n  2354→\n  2355→    // Name pool for looking up names\n  2356→    NamePool namePool;\n  2357→\n  2358→    NamePool* getNamePool() { return &namePool; }\n  2359→\n  2360→    ASTBuilder* getASTBuilder() { return m_astBuilder; }\n  2361→\n  2362→    RefPtr<ASTBuilder> m_astBuilder;\n  2363→\n  2364→    // Cache for container types.\n  2365→    Dictionary<ContainerTypeKey, Type*> m_containerTypes;\n  2366→\n  2367→    // cache used by type checking, implemented in check.cpp\n  2368→    TypeCheckingCache* getTypeCheckingCache();\n  2369→    void destroyTypeCheckingCache();\n  2370→\n  2371→    RefPtr<RefObject> m_typeCheckingCache = nullptr;\n  2372→\n  2373→    // Modules that have been dynamically loaded via `import`\n  2374→    //\n  2375→    // This is a list of unique modules loaded, in the order they were encountered.\n  2376→    List<RefPtr<LoadedModule>> loadedModulesList;\n  2377→\n  2378→    // Map from the path (or uniqueIdentity if available) of a module file to its definition\n  2379→    Dictionary<String, RefPtr<LoadedModule>> mapPathToLoadedModule;\n  2380→\n  2381→    // Map from the logical name of a module to its definition\n  2382→    Dictionary<Name*, RefPtr<LoadedModule>> mapNameToLoadedModules;\n  2383→\n  2384→    // Map from the mangled name of RTTI objects to sequential IDs\n  2385→    // used by `switch`-based dynamic dispatch.\n  2386→    Dictionary<String, uint32_t> mapMangledNameToRTTIObjectIndex;\n  2387→\n  2388→    // Counters for allocating sequential IDs to witness tables conforming to each interface type.\n  2389→    Dictionary<String, uint32_t> mapInterfaceMangledNameToSequentialIDCounters;\n  2390→\n  2391→    SearchDirectoryList searchDirectoryCache;\n  2392→\n  2393→    // The resulting specialized IR module for each entry point request\n  2394→    List<RefPtr<IRModule>> compiledModules;\n  2395→\n  2396→    ContentAssistInfo contentAssistInfo;\n  2397→\n  2398→    /// File system implementation to use when loading files from disk.\n  2399→    ///\n  2400→    /// If this member is `null`, a default implementation that tries\n  2401→    /// to use the native OS filesystem will be used instead.\n  2402→    ///\n  2403→    ComPtr<ISlangFileSystem> m_fileSystem;\n  2404→\n  2405→    /// The extended file system implementation. Will be set to a default implementation\n  2406→    /// if fileSystem is nullptr. Otherwise it will either be fileSystem's interface,\n  2407→    /// or a wrapped impl that makes fileSystem operate as fileSystemExt\n  2408→    ComPtr<ISlangFileSystemExt> m_fileSystemExt;\n  2409→\n  2410→    /// Get the currenly set file system\n  2411→    ISlangFileSystemExt* getFileSystemExt() { return m_fileSystemExt; }\n  2412→\n  2413→    /// Load a file into memory using the configured file system.\n  2414→    ///\n  2415→    /// @param path The path to attempt to load from\n  2416→    /// @param outBlob A destination pointer to receive the loaded blob\n  2417→    /// @returns A `SlangResult` to indicate success or failure.\n  2418→    ///\n  2419→    SlangResult loadFile(String const& path, PathInfo& outPathInfo, ISlangBlob** outBlob);\n  2420→\n  2421→    Expr* parseTermString(String str, Scope* scope);\n  2422→\n  2423→    Type* specializeType(\n  2424→        Type* unspecializedType,\n  2425→        Int argCount,\n  2426→        Type* const* args,\n  2427→        DiagnosticSink* sink);\n  2428→\n  2429→    /// Add a new target and return its index.\n  2430→    UInt addTarget(CodeGenTarget target);\n  2431→\n  2432→    /// \"Bottleneck\" routine for loading a module.\n  2433→    ///\n  2434→    /// All attempts to load a module, whether through\n  2435→    /// Slang API calls, `import` operations, or other\n  2436→    /// means, should bottleneck through `loadModuleImpl`,\n  2437→    /// or one of the specialized cases `loadSourceModuleImpl`\n  2438→    /// and `loadBinaryModuleImpl`.\n  2439→    ///\n  2440→    RefPtr<Module> loadModuleImpl(\n  2441→        Name* name,\n  2442→        const PathInfo& filePathInfo,\n  2443→        ISlangBlob* fileContentsBlob,\n  2444→        SourceLoc const& loc,\n  2445→        DiagnosticSink* sink,\n  2446→        const LoadedModuleDictionary* additionalLoadedModules,\n  2447→        ModuleBlobType blobType);\n  2448→\n  2449→    RefPtr<Module> loadSourceModuleImpl(\n  2450→        Name* name,\n  2451→        const PathInfo& filePathInfo,\n  2452→        ISlangBlob* fileContentsBlob,\n  2453→        SourceLoc const& loc,\n  2454→        DiagnosticSink* sink,\n  2455→        const LoadedModuleDictionary* additionalLoadedModules);\n  2456→\n  2457→    RefPtr<Module> loadBinaryModuleImpl(\n  2458→        Name* name,\n  2459→        const PathInfo& filePathInfo,\n  2460→        ISlangBlob* fileContentsBlob,\n  2461→        SourceLoc const& loc,\n  2462→        DiagnosticSink* sink);\n  2463→\n  2464→    /// Either finds a previously-loaded module matching what\n  2465→    /// was serialized into `moduleChunk`, or else attempts\n  2466→    /// to load the serialized module.\n  2467→    ///\n  2468→    /// If a previously-loaded module is found that matches the\n  2469→    /// name or path information in `moduleChunk`, then that\n  2470→    /// previously-loaded module is returned.\n  2471→    ///\n  2472→    /// Othwerise, attempts to load a module from `moduleChunk`\n  2473→    /// and, if successful, returns the freshly loaded module.\n  2474→    ///\n  2475→    /// Otherwise, return null.\n  2476→    ///\n  2477→    RefPtr<Module> findOrLoadSerializedModuleForModuleLibrary(\n  2478→        ISlangBlob* blobHoldingSerializedData,\n  2479→        ModuleChunk const* moduleChunk,\n  2480→        RIFF::ListChunk const* libraryChunk,\n  2481→        DiagnosticSink* sink);\n  2482→\n  2483→    RefPtr<Module> loadSerializedModule(\n  2484→        Name* moduleName,\n  2485→        const PathInfo& moduleFilePathInfo,\n  2486→        ISlangBlob* blobHoldingSerializedData,\n  2487→        ModuleChunk const* moduleChunk,\n  2488→        RIFF::ListChunk const* containerChunk, //< The outer container, if there is one.\n  2489→        SourceLoc const& requestingLoc,\n  2490→        DiagnosticSink* sink);\n  2491→\n  2492→    SlangResult loadSerializedModuleContents(\n  2493→        Module* module,\n  2494→        const PathInfo& moduleFilePathInfo,\n  2495→        ISlangBlob* blobHoldingSerializedData,\n  2496→        ModuleChunk const* moduleChunk,\n  2497→        RIFF::ListChunk const* containerChunk, //< The outer container, if there is one.\n  2498→        DiagnosticSink* sink);\n  2499→\n  2500→    SourceFile* loadSourceFile(String pathFrom, String path);\n  2501→\n  2502→    void loadParsedModule(\n  2503→        RefPtr<FrontEndCompileRequest> compileRequest,\n  2504→        RefPtr<TranslationUnitRequest> translationUnit,\n  2505→        Name* name,\n  2506→        PathInfo const& pathInfo);\n  2507→\n  2508→    bool isBinaryModuleUpToDate(String fromPath, RIFF::ListChunk const* baseChunk);\n  2509→\n  2510→    RefPtr<Module> findOrImportModule(\n  2511→        Name* name,\n  2512→        SourceLoc const& loc,\n  2513→        DiagnosticSink* sink,\n  2514→        const LoadedModuleDictionary* loadedModules = nullptr);\n  2515→\n  2516→    SourceFile* findFile(Name* name, SourceLoc loc, IncludeSystem& outIncludeSystem);\n  2517→    struct IncludeResult\n  2518→    {\n  2519→        FileDecl* fileDecl;\n  2520→        bool isNew;\n  2521→    };\n  2522→    IncludeResult findAndIncludeFile(\n  2523→        Module* module,\n  2524→        TranslationUnitRequest* translationUnit,\n  2525→        Name* name,\n  2526→        SourceLoc const& loc,\n  2527→        DiagnosticSink* sink);\n  2528→\n  2529→    SourceManager* getSourceManager() { return m_sourceManager; }\n  2530→\n  2531→    /// Override the source manager for the linkage.\n  2532→    ///\n  2533→    /// This is only used to install a temporary override when\n  2534→    /// parsing stuff from strings (where we don't want to retain\n  2535→    /// full source files for the parsed result).\n  2536→    ///\n  2537→    /// TODO: We should remove the need for this hack.\n  2538→    ///\n  2539→    void setSourceManager(SourceManager* sourceManager) { m_sourceManager = sourceManager; }\n  2540→\n  2541→    void setRequireCacheFileSystem(bool requireCacheFileSystem);\n  2542→\n  2543→    void setFileSystem(ISlangFileSystem* fileSystem);\n  2544→\n  2545→    DeclRef<Decl> specializeGeneric(\n  2546→        DeclRef<Decl> declRef,\n  2547→        List<Expr*> argExprs,\n  2548→        DiagnosticSink* sink);\n  2549→\n  2550→    DeclRef<Decl> specializeWithArgTypes(\n  2551→        Expr* funcExpr,\n  2552→        List<Type*> argTypes,\n  2553→        DiagnosticSink* sink);\n  2554→\n  2555→    bool isSpecialized(DeclRef<Decl> declRef);\n  2556→\n  2557→    DiagnosticSink::Flags diagnosticSinkFlags = 0;\n  2558→\n  2559→    bool m_requireCacheFileSystem = false;\n  2560→\n  2561→    // Modules that have been read in with the -r option\n  2562→    List<ComPtr<IArtifact>> m_libModules;\n  2563→\n  2564→    void _stopRetainingParentSession() { m_retainedSession = nullptr; }\n  2565→\n  2566→    // Get shared semantics information for reflection purposes.\n  2567→    SharedSemanticsContext* getSemanticsForReflection();\n  2568→\n  2569→private:\n  2570→    /// The global Slang library session that this linkage is a child of\n  2571→    Session* m_session = nullptr;\n  2572→\n  2573→    RefPtr<Session> m_retainedSession;\n  2574→\n  2575→    /// Tracks state of modules currently being loaded.\n  2576→    ///\n  2577→    /// This information is used to diagnose cases where\n  2578→    /// a user tries to recursively import the same module\n  2579→    /// (possibly along a transitive chain of `import`s).\n  2580→    ///\n  2581→    struct ModuleBeingImportedRAII\n  2582→    {\n  2583→    public:\n  2584→        ModuleBeingImportedRAII(\n  2585→            Linkage* linkage,\n  2586→            Module* module,\n  2587→            Name* name,\n  2588→            SourceLoc const& importLoc)\n  2589→            : linkage(linkage), module(module), name(name), importLoc(importLoc)\n  2590→        {\n  2591→            next = linkage->m_modulesBeingImported;\n  2592→            linkage->m_modulesBeingImported = this;\n  2593→        }\n  2594→\n  2595→        ~ModuleBeingImportedRAII() { linkage->m_modulesBeingImported = next; }\n  2596→\n  2597→        Linkage* linkage;\n  2598→        Module* module;\n  2599→        Name* name;\n  2600→        SourceLoc importLoc;\n  2601→        ModuleBeingImportedRAII* next;\n  2602→    };\n  2603→\n  2604→    // Any modules currently being imported will be listed here\n  2605→    ModuleBeingImportedRAII* m_modulesBeingImported = nullptr;\n  2606→\n  2607→    /// Is the given module in the middle of being imported?\n  2608→    bool isBeingImported(Module* module);\n  2609→\n  2610→    /// Diagnose that an error occured in the process of importing a module\n  2611→    void _diagnoseErrorInImportedModule(DiagnosticSink* sink);\n  2612→\n  2613→    List<Type*> m_specializedTypes;\n  2614→\n  2615→    RefPtr<SharedSemanticsContext> m_semanticsForReflection;\n  2616→};\n  2617→\n  2618→/// Shared functionality between front- and back-end compile requests.\n  2619→///\n  2620→/// This is the base class for both `FrontEndCompileRequest` and\n  2621→/// `BackEndCompileRequest`, and allows a small number of parts of\n  2622→/// the compiler to be easily invocable from either front-end or\n  2623→/// back-end work.\n  2624→///\n  2625→class CompileRequestBase : public RefObject\n  2626→{\n  2627→    // TODO: We really shouldn't need this type in the long run.\n  2628→    // The few places that rely on it should be refactored to just\n  2629→    // depend on the underlying information (a linkage and a diagnostic\n  2630→    // sink) directly.\n  2631→    //\n  2632→    // The flags to control dumping and validation of IR should be\n  2633→    // moved to some kind of shared settings/options `struct` that\n  2634→    // both front-end and back-end requests can store.\n  2635→\n  2636→public:\n  2637→    Session* getSession();\n  2638→    Linkage* getLinkage() { return m_linkage; }\n  2639→    DiagnosticSink* getSink() { return m_sink; }\n  2640→    SourceManager* getSourceManager() { return getLinkage()->getSourceManager(); }\n  2641→    NamePool* getNamePool() { return getLinkage()->getNamePool(); }\n  2642→    ISlangFileSystemExt* getFileSystemExt() { return getLinkage()->getFileSystemExt(); }\n  2643→    SlangResult loadFile(String const& path, PathInfo& outPathInfo, ISlangBlob** outBlob)\n  2644→    {\n  2645→        return getLinkage()->loadFile(path, outPathInfo, outBlob);\n  2646→    }\n  2647→\n  2648→protected:\n  2649→    CompileRequestBase(Linkage* linkage, DiagnosticSink* sink);\n  2650→\n  2651→private:\n  2652→    Linkage* m_linkage = nullptr;\n  2653→    DiagnosticSink* m_sink = nullptr;\n  2654→};\n  2655→\n  2656→/// A request to compile source code to an AST + IR.\n  2657→class FrontEndCompileRequest : public CompileRequestBase\n  2658→{\n  2659→public:\n  2660→    /// Note that writers can be parsed as nullptr to disable output,\n  2661→    /// and individual channels set to null to disable them\n  2662→    FrontEndCompileRequest(Linkage* linkage, StdWriters* writers, DiagnosticSink* sink);\n  2663→\n  2664→    int addEntryPoint(int translationUnitIndex, String const& name, Profile entryPointProfile);\n  2665→\n  2666→    // Translation units we are being asked to compile\n  2667→    List<RefPtr<TranslationUnitRequest>> translationUnits;\n  2668→\n  2669→    // Additional modules that needs to be made visible to `import` while checking.\n  2670→    const LoadedModuleDictionary* additionalLoadedModules = nullptr;\n  2671→\n  2672→    RefPtr<TranslationUnitRequest> getTranslationUnit(UInt index)\n  2673→    {\n  2674→        return translationUnits[index];\n  2675→    }\n  2676→\n  2677→    // If true will serialize and de-serialize with debug information\n  2678→    bool verifyDebugSerialization = false;\n  2679→\n  2680→    CompilerOptionSet optionSet;\n  2681→\n  2682→    List<RefPtr<FrontEndEntryPointRequest>> m_entryPointReqs;\n  2683→\n  2684→    List<RefPtr<FrontEndEntryPointRequest>> const& getEntryPointReqs() { return m_entryPointReqs; }\n  2685→    UInt getEntryPointReqCount() { return m_entryPointReqs.getCount(); }\n  2686→    FrontEndEntryPointRequest* getEntryPointReq(UInt index) { return m_entryPointReqs[index]; }\n  2687→\n  2688→    void parseTranslationUnit(TranslationUnitRequest* translationUnit);\n  2689→\n  2690→    // Perform primary semantic checking on all\n  2691→    // of the translation units in the program\n  2692→    void checkAllTranslationUnits();\n  2693→\n  2694→    void checkEntryPoints();\n  2695→\n  2696→    void generateIR();\n  2697→\n  2698→    SlangResult executeActionsInner();\n  2699→\n  2700→    /// Add a translation unit to be compiled.\n  2701→    ///\n  2702→    /// @param language The source language that the translation unit will use (e.g.,\n  2703→    /// `SourceLanguage::Slang`\n  2704→    /// @param moduleName The name that will be used for the module compile from the translation\n  2705→    /// unit.\n  2706→    ///\n  2707→    /// If moduleName is passed as nullptr a module name is generated.\n  2708→    /// If all translation units in a compile request use automatically generated\n  2709→    /// module names, then they are guaranteed not to conflict with one another.\n  2710→    ///\n  2711→    /// @return The zero-based index of the translation unit in this compile request.\n  2712→    int addTranslationUnit(SourceLanguage language, Name* moduleName);\n  2713→\n  2714→    int addTranslationUnit(TranslationUnitRequest* translationUnit);\n  2715→\n  2716→    void addTranslationUnitSourceArtifact(int translationUnitIndex, IArtifact* sourceArtifact);\n  2717→\n  2718→    void addTranslationUnitSourceBlob(\n  2719→        int translationUnitIndex,\n  2720→        String const& path,\n  2721→        ISlangBlob* sourceBlob);\n  2722→\n  2723→    void addTranslationUnitSourceFile(int translationUnitIndex, String const& path);\n  2724→\n  2725→    /// Get a component type that represents the global scope of the compile request.\n  2726→    ComponentType* getGlobalComponentType() { return m_globalComponentType; }\n  2727→\n  2728→    /// Get a component type that represents the global scope of the compile request, plus the\n  2729→    /// requested entry points.\n  2730→    ComponentType* getGlobalAndEntryPointsComponentType()\n  2731→    {\n  2732→        return m_globalAndEntryPointsComponentType;\n  2733→    }\n  2734→\n  2735→    List<RefPtr<ComponentType>> const& getUnspecializedEntryPoints()\n  2736→    {\n  2737→        return m_unspecializedEntryPoints;\n  2738→    }\n  2739→\n  2740→    /// Does the code we are compiling represent part of the Slang core module?\n  2741→    bool m_isCoreModuleCode = false;\n  2742→\n  2743→    Name* m_defaultModuleName = nullptr;\n  2744→\n  2745→    /// The irDumpOptions\n  2746→    IRDumpOptions m_irDumpOptions;\n  2747→\n  2748→    /// An \"extra\" entry point that was added via a library reference\n  2749→    struct ExtraEntryPointInfo\n  2750→    {\n  2751→        Name* name;\n  2752→        Profile profile;\n  2753→        String mangledName;\n  2754→    };\n  2755→\n  2756→    /// A list of \"extra\" entry points added via a library reference\n  2757→    List<ExtraEntryPointInfo> m_extraEntryPoints;\n  2758→\n  2759→private:\n  2760→    /// A component type that includes only the global scopes of the translation unit(s) that were\n  2761→    /// compiled.\n  2762→    RefPtr<ComponentType> m_globalComponentType;\n  2763→\n  2764→    /// A component type that extends the global scopes with all of the entry points that were\n  2765→    /// specified.\n  2766→    RefPtr<ComponentType> m_globalAndEntryPointsComponentType;\n  2767→\n  2768→    List<RefPtr<ComponentType>> m_unspecializedEntryPoints;\n  2769→\n  2770→    RefPtr<StdWriters> m_writers;\n  2771→};\n  2772→\n  2773→/// A visitor for use with `ComponentType`s, allowing dispatch over the concrete subclasses.\n  2774→class ComponentTypeVisitor\n  2775→{\n  2776→public:\n  2777→    // The following methods should be overriden in a concrete subclass\n  2778→    // to customize how it acts on each of the concrete types of component.\n  2779→    //\n  2780→    // In cases where the application wants to simply \"recurse\" on a\n  2781→    // composite, specialized, or legacy component type it can use\n  2782→    // the `visitChildren` methods below.\n  2783→    //\n  2784→    virtual void visitEntryPoint(\n  2785→        EntryPoint* entryPoint,\n  2786→        EntryPoint::EntryPointSpecializationInfo* specializationInfo) = 0;\n  2787→    virtual void visitModule(\n  2788→        Module* module,\n  2789→        Module::ModuleSpecializationInfo* specializationInfo) = 0;\n  2790→    virtual void visitComposite(\n  2791→        CompositeComponentType* composite,\n  2792→        CompositeComponentType::CompositeSpecializationInfo* specializationInfo) = 0;\n  2793→    virtual void visitSpecialized(SpecializedComponentType* specialized) = 0;\n  2794→    virtual void visitTypeConformance(TypeConformance* conformance) = 0;\n  2795→    virtual void visitRenamedEntryPoint(\n  2796→        RenamedEntryPointComponentType* renamedEntryPoint,\n  2797→        EntryPoint::EntryPointSpecializationInfo* specializationInfo) = 0;\n  2798→\n  2799→protected:\n  2800→    // These helpers can be used to recurse into the logical children of a\n  2801→    // component type, and are useful for the common case where a visitor\n  2802→    // only cares about a few leaf cases.\n  2803→    //\n  2804→    void visitChildren(\n  2805→        CompositeComponentType* composite,\n  2806→        CompositeComponentType::CompositeSpecializationInfo* specializationInfo);\n  2807→    void visitChildren(SpecializedComponentType* specialized);\n  2808→};\n  2809→\n  2810→/// A `TargetProgram` represents a `ComponentType` specialized for a particular `TargetRequest`\n  2811→///\n  2812→/// TODO: This should probably be renamed to `TargetComponentType`.\n  2813→///\n  2814→/// By binding a component type to a specific target, a `TargetProgram` allows\n  2815→/// for things like layout to be computed, that fundamentally depend on\n  2816→/// the choice of target.\n  2817→///\n  2818→/// A `TargetProgram` handles request for compiled kernel code for\n  2819→/// entry point functions. In practice, kernel code can only be\n  2820→/// correctly generated when the underlying `ComponentType` is \"fully linked\"\n  2821→/// (has no remaining unsatisfied requirements).\n  2822→///\n  2823→class TargetProgram : public RefObject\n  2824→{\n  2825→public:\n  2826→    TargetProgram(ComponentType* componentType, TargetRequest* targetReq);\n  2827→\n  2828→    /// Get the underlying program\n  2829→    ComponentType* getProgram() { return m_program; }\n  2830→\n  2831→    /// Get the underlying target\n  2832→    TargetRequest* getTargetReq() { return m_targetReq; }\n  2833→\n  2834→    /// Get the layout for the program on the target.\n  2835→    ///\n  2836→    /// If this is the first time the layout has been\n  2837→    /// requested, report any errors that arise during\n  2838→    /// layout to the given `sink`.\n  2839→    ///\n  2840→    ProgramLayout* getOrCreateLayout(DiagnosticSink* sink);\n  2841→\n  2842→    /// Get the layout for the program on the target.\n  2843→    ///\n  2844→    /// This routine assumes that `getOrCreateLayout`\n  2845→    /// has already been called previously.\n  2846→    ///\n  2847→    ProgramLayout* getExistingLayout()\n  2848→    {\n  2849→        SLANG_ASSERT(m_layout);\n  2850→        return m_layout;\n  2851→    }\n  2852→\n  2853→    /// Get the compiled code for an entry point on the target.\n  2854→    ///\n  2855→    /// If this is the first time that code generation has\n  2856→    /// been requested, report any errors that arise during\n  2857→    /// code generation to the given `sink`.\n  2858→    ///\n  2859→    IArtifact* getOrCreateEntryPointResult(Int entryPointIndex, DiagnosticSink* sink);\n  2860→    IArtifact* getOrCreateWholeProgramResult(DiagnosticSink* sink);\n  2861→\n  2862→    IArtifact* getExistingWholeProgramResult() { return m_wholeProgramResult; }\n  2863→    /// Get the compiled code for an entry point on the target.\n  2864→    ///\n  2865→    /// This routine assumes that `getOrCreateEntryPointResult`\n  2866→    /// has already been called previously.\n  2867→    ///\n  2868→    IArtifact* getExistingEntryPointResult(Int entryPointIndex)\n  2869→    {\n  2870→        return m_entryPointResults[entryPointIndex];\n  2871→    }\n  2872→\n  2873→    IArtifact* _createWholeProgramResult(\n  2874→        DiagnosticSink* sink,\n  2875→        EndToEndCompileRequest* endToEndReq = nullptr);\n  2876→\n  2877→    /// Internal helper for `getOrCreateEntryPointResult`.\n  2878→    ///\n  2879→    /// This is used so that command-line and API-based\n  2880→    /// requests for code can bottleneck through the same place.\n  2881→    ///\n  2882→    /// Shouldn't be called directly by most code.\n  2883→    ///\n  2884→    IArtifact* _createEntryPointResult(\n  2885→        Int entryPointIndex,\n  2886→        DiagnosticSink* sink,\n  2887→        EndToEndCompileRequest* endToEndReq = nullptr);\n  2888→\n  2889→    RefPtr<IRModule> getOrCreateIRModuleForLayout(DiagnosticSink* sink);\n  2890→\n  2891→    RefPtr<IRModule> getExistingIRModuleForLayout() { return m_irModuleForLayout; }\n  2892→\n  2893→    CompilerOptionSet& getOptionSet() { return m_optionSet; }\n  2894→\n  2895→    HLSLToVulkanLayoutOptions* getHLSLToVulkanLayoutOptions()\n  2896→    {\n  2897→        return m_targetReq->getHLSLToVulkanLayoutOptions();\n  2898→    }\n  2899→\n  2900→    bool shouldEmitSPIRVDirectly()\n  2901→    {\n  2902→        return isKhronosTarget(m_targetReq) && getOptionSet().shouldEmitSPIRVDirectly();\n  2903→    }\n  2904→\n  2905→private:\n  2906→    RefPtr<IRModule> createIRModuleForLayout(DiagnosticSink* sink);\n  2907→\n  2908→    // The program being compiled or laid out\n  2909→    ComponentType* m_program;\n  2910→\n  2911→    // The target that code/layout will be generated for\n  2912→    TargetRequest* m_targetReq;\n  2913→\n  2914→    // The computed layout, if it has been generated yet\n  2915→    RefPtr<ProgramLayout> m_layout;\n  2916→\n  2917→    CompilerOptionSet m_optionSet;\n  2918→\n  2919→    // Generated compile results for each entry point\n  2920→    // in the parent `Program` (indexing matches\n  2921→    // the order they are given in the `Program`)\n  2922→    ComPtr<IArtifact> m_wholeProgramResult;\n  2923→    List<ComPtr<IArtifact>> m_entryPointResults;\n  2924→\n  2925→    RefPtr<IRModule> m_irModuleForLayout;\n  2926→};\n  2927→\n  2928→/// A back-end-specific object to track optional feaures/capabilities/extensions\n  2929→/// that are discovered to be used by a program/kernel as part of code generation.\n  2930→class ExtensionTracker : public RefObject\n  2931→{\n  2932→    // TODO: The existence of this type is evidence of a design/architecture problem.\n  2933→    //\n  2934→    // A better formulation of things requires a few key changes:\n  2935→    //\n  2936→    // 1. All optional capabilities need to be enumerated as part of the `CapabilitySet`\n  2937→    //  system, so that they can be reasoned about uniformly across different targets\n  2938→    //  and different layers of the compiler.\n  2939→    //\n  2940→    // 2. The front-end should be responsible for either or both of:\n  2941→    //\n  2942→    //   * Checking that `public` or otherwise externally-visible items (declarations/definitions)\n  2943→    //     explicitly declare the capabilities they require, and that they only ever\n  2944→    //     make use of items that are comatible with those required capabilities.\n  2945→    //\n  2946→    //   * Inferring the capabilities required by items that are not externally visible,\n  2947→    //     and attaching those capabilities explicit as a modifier or other synthesized AST node.\n  2948→    //\n  2949→    // 3. The capabilities required by a given `ComponentType` and its entry points should be\n  2950→    // explicitly know-able, and they should be something we can compare to the capabilities\n  2951→    // of a code generation target *before* back-end code generation is started. We should be\n  2952→    // able to issue error messages around lacking capabilities in a way the user can understand,\n  2953→    // in terms of the high-level-language entities.\n  2954→\n  2955→public:\n  2956→};\n  2957→\n  2958→struct RequiredLoweringPassSet\n  2959→{\n  2960→    bool debugInfo;\n  2961→    bool resultType;\n  2962→    bool optionalType;\n  2963→    bool enumType;\n  2964→    bool combinedTextureSamplers;\n  2965→    bool reinterpret;\n  2966→    bool generics;\n  2967→    bool bindExistential;\n  2968→    bool autodiff;\n  2969→    bool derivativePyBindWrapper;\n  2970→    bool bitcast;\n  2971→    bool existentialTypeLayout;\n  2972→    bool bindingQuery;\n  2973→    bool meshOutput;\n  2974→    bool higherOrderFunc;\n  2975→    bool globalVaryingVar;\n  2976→    bool glslSSBO;\n  2977→    bool byteAddressBuffer;\n  2978→    bool dynamicResource;\n  2979→    bool dynamicResourceHeap;\n  2980→    bool resolveVaryingInputRef;\n  2981→    bool specializeStageSwitch;\n  2982→    bool missingReturn;\n  2983→    bool nonVectorCompositeSelect;\n  2984→};\n  2985→\n  2986→/// A context for code generation in the compiler back-end\n  2987→struct CodeGenContext\n  2988→{\n  2989→public:\n  2990→    typedef List<Index> EntryPointIndices;\n  2991→\n  2992→    struct Shared\n  2993→    {\n  2994→    public:\n  2995→        Shared(\n  2996→            TargetProgram* targetProgram,\n  2997→            EntryPointIndices const& entryPointIndices,\n  2998→            DiagnosticSink* sink,\n  2999→            EndToEndCompileRequest* endToEndReq)\n  3000→            : targetProgram(targetProgram)\n  3001→            , entryPointIndices(entryPointIndices)\n  3002→            , sink(sink)\n  3003→            , endToEndReq(endToEndReq)\n  3004→        {\n  3005→        }\n  3006→\n  3007→        //            Shared(\n  3008→        //                TargetProgram*              targetProgram,\n  3009→        //                EndToEndCompileRequest*     endToEndReq);\n  3010→\n  3011→        TargetProgram* targetProgram = nullptr;\n  3012→        EntryPointIndices entryPointIndices;\n  3013→        DiagnosticSink* sink = nullptr;\n  3014→        EndToEndCompileRequest* endToEndReq = nullptr;\n  3015→    };\n  3016→\n  3017→    CodeGenContext(Shared* shared)\n  3018→        : m_shared(shared)\n  3019→        , m_targetFormat(shared->targetProgram->getTargetReq()->getTarget())\n  3020→        , m_targetProfile(shared->targetProgram->getOptionSet().getProfile())\n  3021→    {\n  3022→    }\n  3023→\n  3024→    CodeGenContext(\n  3025→        CodeGenContext* base,\n  3026→        CodeGenTarget targetFormat,\n  3027→        ExtensionTracker* extensionTracker = nullptr)\n  3028→        : m_shared(base->m_shared)\n  3029→        , m_targetFormat(targetFormat)\n  3030→        , m_extensionTracker(extensionTracker)\n  3031→    {\n  3032→    }\n  3033→\n  3034→    /// Get the diagnostic sink\n  3035→    DiagnosticSink* getSink() { return m_shared->sink; }\n  3036→\n  3037→    TargetProgram* getTargetProgram() { return m_shared->targetProgram; }\n  3038→\n  3039→    EntryPointIndices const& getEntryPointIndices() { return m_shared->entryPointIndices; }\n  3040→\n  3041→    CodeGenTarget getTargetFormat() { return m_targetFormat; }\n  3042→\n  3043→    ExtensionTracker* getExtensionTracker() { return m_extensionTracker; }\n  3044→\n  3045→    TargetRequest* getTargetReq() { return getTargetProgram()->getTargetReq(); }\n  3046→\n  3047→    CapabilitySet getTargetCaps() { return getTargetReq()->getTargetCaps(); }\n  3048→\n  3049→    CodeGenTarget getFinalTargetFormat() { return getTargetReq()->getTarget(); }\n  3050→\n  3051→    ComponentType* getProgram() { return getTargetProgram()->getProgram(); }\n  3052→\n  3053→    Linkage* getLinkage() { return getProgram()->getLinkage(); }\n  3054→\n  3055→    Session* getSession() { return getLinkage()->getSessionImpl(); }\n  3056→\n  3057→    /// Get the source manager\n  3058→    SourceManager* getSourceManager() { return getLinkage()->getSourceManager(); }\n  3059→\n  3060→    ISlangFileSystemExt* getFileSystemExt() { return getLinkage()->getFileSystemExt(); }\n  3061→\n  3062→    EndToEndCompileRequest* isEndToEndCompile() { return m_shared->endToEndReq; }\n  3063→\n  3064→    EndToEndCompileRequest* isPassThroughEnabled();\n  3065→\n  3066→    Count getEntryPointCount() { return getEntryPointIndices().getCount(); }\n  3067→\n  3068→    EntryPoint* getEntryPoint(Index index) { return getProgram()->getEntryPoint(index); }\n  3069→\n  3070→    Index getSingleEntryPointIndex()\n  3071→    {\n  3072→        SLANG_ASSERT(getEntryPointCount() == 1);\n  3073→        return getEntryPointIndices()[0];\n  3074→    }\n  3075→\n  3076→    //\n  3077→\n  3078→    IRDumpOptions getIRDumpOptions();\n  3079→\n  3080→    bool shouldValidateIR();\n  3081→    bool shouldDumpIR();\n  3082→    bool shouldReportCheckpointIntermediates();\n  3083→\n  3084→    bool shouldTrackLiveness();\n  3085→\n  3086→    bool shouldDumpIntermediates();\n  3087→    String getIntermediateDumpPrefix();\n  3088→\n  3089→    bool getUseUnknownImageFormatAsDefault();\n  3090→\n  3091→    bool isSpecializationDisabled();\n  3092→\n  3093→    bool shouldSkipSPIRVValidation();\n  3094→\n  3095→    SlangResult requireTranslationUnitSourceFiles();\n  3096→\n  3097→    //\n  3098→\n  3099→    SlangResult emitEntryPoints(ComPtr<IArtifact>& outArtifact);\n  3100→\n  3101→    SlangResult emitPrecompiledDownstreamIR(ComPtr<IArtifact>& outArtifact);\n  3102→\n  3103→    void maybeDumpIntermediate(IArtifact* artifact);\n  3104→\n  3105→    // Used to cause instructions available in precompiled blobs to be\n  3106→    // removed between IR linking and target source generation.\n  3107→    bool removeAvailableInDownstreamIR = false;\n  3108→\n  3109→    // Determines if program level compilation like getTargetCode() or getEntryPointCode()\n  3110→    // should return a fully linked downstream program or just the glue SPIR-V/DXIL that\n  3111→    // imports and uses the precompiled SPIR-V/DXIL from constituent modules.\n  3112→    // This is a no-op if modules are not precompiled.\n  3113→    bool shouldSkipDownstreamLinking();\n  3114→\n  3115→    RequiredLoweringPassSet& getRequiredLoweringPassSet() { return m_requiredLoweringPassSet; }\n  3116→\n  3117→protected:\n  3118→    CodeGenTarget m_targetFormat = CodeGenTarget::Unknown;\n  3119→    Profile m_targetProfile;\n  3120→    ExtensionTracker* m_extensionTracker = nullptr;\n  3121→\n  3122→    // To improve the performance of our backend, we will try to avoid running\n  3123→    // passes related to features not used in the user code.\n  3124→    // To do so, we will scan the IR module once, and determine which passes are needed\n  3125→    // based on the instructions used in the IR module.\n  3126→    // This will allow us to skip running passes that are not needed, without having to\n  3127→    // run all the passes only to find out that no work is needed.\n  3128→    // This is especially important for the performance of the backend, as some passes\n  3129→    // have an initialization cost (such as building reference graphs or DOM trees) that\n  3130→    // can be expensive.\n  3131→    RequiredLoweringPassSet m_requiredLoweringPassSet;\n  3132→\n  3133→    /// Will output assembly as well as the artifact if appropriate for the artifact type for\n  3134→    /// assembly output and conversion is possible\n  3135→    void _dumpIntermediateMaybeWithAssembly(IArtifact* artifact);\n  3136→\n  3137→    void _dumpIntermediate(IArtifact* artifact);\n  3138→    void _dumpIntermediate(const ArtifactDesc& desc, void const* data, size_t size);\n  3139→\n  3140→    /* Emits entry point source taking into account if a pass-through or not. Uses 'targetFormat' to\n  3141→    determine the target (not targetReq) */\n  3142→    SlangResult emitEntryPointsSource(ComPtr<IArtifact>& outArtifact);\n  3143→\n  3144→    SlangResult emitEntryPointsSourceFromIR(ComPtr<IArtifact>& outArtifact);\n  3145→\n  3146→    SlangResult emitWithDownstreamForEntryPoints(ComPtr<IArtifact>& outArtifact);\n  3147→\n  3148→    /* Determines a suitable filename to identify the input for a given entry point being compiled.\n  3149→    If the end-to-end compile is a pass-through case, will attempt to find the (unique) source file\n  3150→    pathname for the translation unit containing the entry point at `entryPointIndex.\n  3151→    If the compilation is not in a pass-through case, then always returns `\"slang-generated\"`.\n  3152→    @param endToEndReq The end-to-end compile request which might be using pass-through compilation\n  3153→    @param entryPointIndex The index of the entry point to compute a filename for.\n  3154→    @return the appropriate source filename */\n  3155→    String calcSourcePathForEntryPoints();\n  3156→\n  3157→    TranslationUnitRequest* findPassThroughTranslationUnit(Int entryPointIndex);\n  3158→\n  3159→\n  3160→    SlangResult _emitEntryPoints(ComPtr<IArtifact>& outArtifact);\n  3161→\n  3162→private:\n  3163→    Shared* m_shared = nullptr;\n  3164→};\n  3165→\n  3166→/// A compile request that spans the front and back ends of the compiler\n  3167→///\n  3168→/// This is what the command-line `slangc` uses, as well as the legacy\n  3169→/// C API. It ties together the functionality of `Linkage`,\n  3170→/// `FrontEndCompileRequest`, and `BackEndCompileRequest`, plus a small\n  3171→/// number of additional features that primarily make sense for\n  3172→/// command-line usage.\n  3173→///\n  3174→class EndToEndCompileRequest : public RefObject, public slang::ICompileRequest\n  3175→{\n  3176→public:\n  3177→    SLANG_CLASS_GUID(0xce6d2383, 0xee1b, 0x4fd7, {0xa0, 0xf, 0xb8, 0xb6, 0x33, 0x12, 0x95, 0xc8})\n  3178→\n  3179→    // ISlangUnknown\n  3180→    SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject)\n  3181→        SLANG_OVERRIDE;\n  3182→    SLANG_REF_OBJECT_IUNKNOWN_ADD_REF\n  3183→    SLANG_REF_OBJECT_IUNKNOWN_RELEASE\n  3184→\n  3185→    // slang::ICompileRequest\n  3186→    virtual SLANG_NO_THROW void SLANG_MCALL setFileSystem(ISlangFileSystem* fileSystem)\n  3187→        SLANG_OVERRIDE;\n  3188→    virtual SLANG_NO_THROW void SLANG_MCALL setCompileFlags(SlangCompileFlags flags) SLANG_OVERRIDE;\n  3189→    virtual SLANG_NO_THROW SlangCompileFlags SLANG_MCALL getCompileFlags() SLANG_OVERRIDE;\n  3190→    virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediates(int enable) SLANG_OVERRIDE;\n  3191→    virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediatePrefix(const char* prefix)\n  3192→        SLANG_OVERRIDE;\n  3193→    virtual SLANG_NO_THROW void SLANG_MCALL setEnableEffectAnnotations(bool value) SLANG_OVERRIDE;\n  3194→    virtual SLANG_NO_THROW void SLANG_MCALL setLineDirectiveMode(SlangLineDirectiveMode mode)\n  3195→        SLANG_OVERRIDE;\n  3196→    virtual SLANG_NO_THROW void SLANG_MCALL setCodeGenTarget(SlangCompileTarget target)\n  3197→        SLANG_OVERRIDE;\n  3198→    virtual SLANG_NO_THROW int SLANG_MCALL addCodeGenTarget(SlangCompileTarget target)\n  3199→        SLANG_OVERRIDE;\n  3200→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3201→    setTargetProfile(int targetIndex, SlangProfileID profile) SLANG_OVERRIDE;\n  3202→    virtual SLANG_NO_THROW void SLANG_MCALL setTargetFlags(int targetIndex, SlangTargetFlags flags)\n  3203→        SLANG_OVERRIDE;\n  3204→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3205→    setTargetFloatingPointMode(int targetIndex, SlangFloatingPointMode mode) SLANG_OVERRIDE;\n  3206→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3207→    setTargetMatrixLayoutMode(int targetIndex, SlangMatrixLayoutMode mode) SLANG_OVERRIDE;\n  3208→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3209→    setTargetForceGLSLScalarBufferLayout(int targetIndex, bool value) SLANG_OVERRIDE;\n  3210→    virtual SLANG_NO_THROW void SLANG_MCALL setTargetForceDXLayout(int targetIndex, bool value)\n  3211→        SLANG_OVERRIDE;\n  3212→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3213→    setTargetGenerateWholeProgram(int targetIndex, bool value) SLANG_OVERRIDE;\n  3214→    virtual SLANG_NO_THROW void SLANG_MCALL setTargetEmbedDownstreamIR(int targetIndex, bool value)\n  3215→        SLANG_OVERRIDE;\n  3216→    virtual SLANG_NO_THROW void SLANG_MCALL setMatrixLayoutMode(SlangMatrixLayoutMode mode)\n  3217→        SLANG_OVERRIDE;\n  3218→    virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoLevel(SlangDebugInfoLevel level)\n  3219→        SLANG_OVERRIDE;\n  3220→    virtual SLANG_NO_THROW void SLANG_MCALL setOptimizationLevel(SlangOptimizationLevel level)\n  3221→        SLANG_OVERRIDE;\n  3222→    virtual SLANG_NO_THROW void SLANG_MCALL setOutputContainerFormat(SlangContainerFormat format)\n  3223→        SLANG_OVERRIDE;\n  3224→    virtual SLANG_NO_THROW void SLANG_MCALL setPassThrough(SlangPassThrough passThrough)\n  3225→        SLANG_OVERRIDE;\n  3226→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3227→    setDiagnosticCallback(SlangDiagnosticCallback callback, void const* userData) SLANG_OVERRIDE;\n  3228→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3229→    setWriter(SlangWriterChannel channel, ISlangWriter* writer) SLANG_OVERRIDE;\n  3230→    virtual SLANG_NO_THROW ISlangWriter* SLANG_MCALL getWriter(SlangWriterChannel channel)\n  3231→        SLANG_OVERRIDE;\n  3232→    virtual SLANG_NO_THROW void SLANG_MCALL addSearchPath(const char* searchDir) SLANG_OVERRIDE;\n  3233→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3234→    addPreprocessorDefine(const char* key, const char* value) SLANG_OVERRIDE;\n  3235→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3236→    processCommandLineArguments(char const* const* args, int argCount) SLANG_OVERRIDE;\n  3237→    virtual SLANG_NO_THROW int SLANG_MCALL\n  3238→    addTranslationUnit(SlangSourceLanguage language, char const* name) SLANG_OVERRIDE;\n  3239→    virtual SLANG_NO_THROW void SLANG_MCALL setDefaultModuleName(const char* defaultModuleName)\n  3240→        SLANG_OVERRIDE;\n  3241→    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitPreprocessorDefine(\n  3242→        int translationUnitIndex,\n  3243→        const char* key,\n  3244→        const char* value) SLANG_OVERRIDE;\n  3245→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3246→    addTranslationUnitSourceFile(int translationUnitIndex, char const* path) SLANG_OVERRIDE;\n  3247→    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceString(\n  3248→        int translationUnitIndex,\n  3249→        char const* path,\n  3250→        char const* source) SLANG_OVERRIDE;\n  3251→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL addLibraryReference(\n  3252→        const char* basePath,\n  3253→        const void* libData,\n  3254→        size_t libDataSize) SLANG_OVERRIDE;\n  3255→    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceStringSpan(\n  3256→        int translationUnitIndex,\n  3257→        char const* path,\n  3258→        char const* sourceBegin,\n  3259→        char const* sourceEnd) SLANG_OVERRIDE;\n  3260→    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceBlob(\n  3261→        int translationUnitIndex,\n  3262→        char const* path,\n  3263→        ISlangBlob* sourceBlob) SLANG_OVERRIDE;\n  3264→    virtual SLANG_NO_THROW int SLANG_MCALL\n  3265→    addEntryPoint(int translationUnitIndex, char const* name, SlangStage stage) SLANG_OVERRIDE;\n  3266→    virtual SLANG_NO_THROW int SLANG_MCALL addEntryPointEx(\n  3267→        int translationUnitIndex,\n  3268→        char const* name,\n  3269→        SlangStage stage,\n  3270→        int genericArgCount,\n  3271→        char const** genericArgs) SLANG_OVERRIDE;\n  3272→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3273→    setGlobalGenericArgs(int genericArgCount, char const** genericArgs) SLANG_OVERRIDE;\n  3274→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3275→    setTypeNameForGlobalExistentialTypeParam(int slotIndex, char const* typeName) SLANG_OVERRIDE;\n  3276→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForEntryPointExistentialTypeParam(\n  3277→        int entryPointIndex,\n  3278→        int slotIndex,\n  3279→        char const* typeName) SLANG_OVERRIDE;\n  3280→    virtual SLANG_NO_THROW void SLANG_MCALL setAllowGLSLInput(bool value) SLANG_OVERRIDE;\n  3281→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL compile() SLANG_OVERRIDE;\n  3282→    virtual SLANG_NO_THROW char const* SLANG_MCALL getDiagnosticOutput() SLANG_OVERRIDE;\n  3283→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getDiagnosticOutputBlob(ISlangBlob** outBlob)\n  3284→        SLANG_OVERRIDE;\n  3285→    virtual SLANG_NO_THROW int SLANG_MCALL getDependencyFileCount() SLANG_OVERRIDE;\n  3286→    virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(int index) SLANG_OVERRIDE;\n  3287→    virtual SLANG_NO_THROW int SLANG_MCALL getTranslationUnitCount() SLANG_OVERRIDE;\n  3288→    virtual SLANG_NO_THROW char const* SLANG_MCALL getEntryPointSource(int entryPointIndex)\n  3289→        SLANG_OVERRIDE;\n  3290→    virtual SLANG_NO_THROW void const* SLANG_MCALL\n  3291→    getEntryPointCode(int entryPointIndex, size_t* outSize) SLANG_OVERRIDE;\n  3292→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCodeBlob(\n  3293→        int entryPointIndex,\n  3294→        int targetIndex,\n  3295→        ISlangBlob** outBlob) SLANG_OVERRIDE;\n  3296→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n  3297→        int entryPointIndex,\n  3298→        int targetIndex,\n  3299→        ISlangSharedLibrary** outSharedLibrary) SLANG_OVERRIDE;\n  3300→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3301→    getTargetCodeBlob(int targetIndex, ISlangBlob** outBlob) SLANG_OVERRIDE;\n  3302→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3303→    getTargetHostCallable(int targetIndex, ISlangSharedLibrary** outSharedLibrary) SLANG_OVERRIDE;\n  3304→    virtual SLANG_NO_THROW void const* SLANG_MCALL getCompileRequestCode(size_t* outSize)\n  3305→        SLANG_OVERRIDE;\n  3306→    virtual SLANG_NO_THROW ISlangMutableFileSystem* SLANG_MCALL\n  3307→    getCompileRequestResultAsFileSystem() SLANG_OVERRIDE;\n  3308→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getContainerCode(ISlangBlob** outBlob)\n  3309→        SLANG_OVERRIDE;\n  3310→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3311→    loadRepro(ISlangFileSystem* fileSystem, const void* data, size_t size) SLANG_OVERRIDE;\n  3312→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveRepro(ISlangBlob** outBlob) SLANG_OVERRIDE;\n  3313→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL enableReproCapture() SLANG_OVERRIDE;\n  3314→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getProgram(slang::IComponentType** outProgram)\n  3315→        SLANG_OVERRIDE;\n  3316→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3317→    getEntryPoint(SlangInt entryPointIndex, slang::IComponentType** outEntryPoint) SLANG_OVERRIDE;\n  3318→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3319→    getModule(SlangInt translationUnitIndex, slang::IModule** outModule) SLANG_OVERRIDE;\n  3320→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSession(slang::ISession** outSession)\n  3321→        SLANG_OVERRIDE;\n  3322→    virtual SLANG_NO_THROW SlangReflection* SLANG_MCALL getReflection() SLANG_OVERRIDE;\n  3323→    virtual SLANG_NO_THROW void SLANG_MCALL setCommandLineCompilerMode() SLANG_OVERRIDE;\n  3324→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3325→    addTargetCapability(SlangInt targetIndex, SlangCapabilityID capability) SLANG_OVERRIDE;\n  3326→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3327→    getProgramWithEntryPoints(slang::IComponentType** outProgram) SLANG_OVERRIDE;\n  3328→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL isParameterLocationUsed(\n  3329→        SlangInt entryPointIndex,\n  3330→        SlangInt targetIndex,\n  3331→        SlangParameterCategory category,\n  3332→        SlangUInt spaceIndex,\n  3333→        SlangUInt registerIndex,\n  3334→        bool& outUsed) SLANG_OVERRIDE;\n  3335→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3336→    setTargetLineDirectiveMode(SlangInt targetIndex, SlangLineDirectiveMode mode) SLANG_OVERRIDE;\n  3337→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3338→    overrideDiagnosticSeverity(SlangInt messageID, SlangSeverity overrideSeverity) SLANG_OVERRIDE;\n  3339→    virtual SLANG_NO_THROW SlangDiagnosticFlags SLANG_MCALL getDiagnosticFlags() SLANG_OVERRIDE;\n  3340→    virtual SLANG_NO_THROW void SLANG_MCALL setDiagnosticFlags(SlangDiagnosticFlags flags)\n  3341→        SLANG_OVERRIDE;\n  3342→    virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoFormat(SlangDebugInfoFormat format)\n  3343→        SLANG_OVERRIDE;\n  3344→    virtual SLANG_NO_THROW void SLANG_MCALL setReportDownstreamTime(bool value) SLANG_OVERRIDE;\n  3345→    virtual SLANG_NO_THROW void SLANG_MCALL setReportPerfBenchmark(bool value) SLANG_OVERRIDE;\n  3346→    virtual SLANG_NO_THROW void SLANG_MCALL setSkipSPIRVValidation(bool value) SLANG_OVERRIDE;\n  3347→    virtual SLANG_NO_THROW void SLANG_MCALL\n  3348→    setTargetUseMinimumSlangOptimization(int targetIndex, bool value) SLANG_OVERRIDE;\n  3349→    virtual SLANG_NO_THROW void SLANG_MCALL setIgnoreCapabilityCheck(bool value) SLANG_OVERRIDE;\n  3350→    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n  3351→    getCompileTimeProfile(ISlangProfiler** compileTimeProfile, bool isClear) SLANG_OVERRIDE;\n  3352→\n  3353→    void setTrackLiveness(bool v);\n  3354→\n  3355→    EndToEndCompileRequest(Session* session);\n  3356→\n  3357→    EndToEndCompileRequest(Linkage* linkage);\n  3358→\n  3359→    ~EndToEndCompileRequest();\n  3360→\n  3361→    // If enabled will emit IR\n  3362→    bool m_emitIr = false;\n  3363→\n  3364→    // What container format are we being asked to generate?\n  3365→    // If it's set to a format, the container blob will be calculated during compile\n  3366→    ContainerFormat m_containerFormat = ContainerFormat::None;\n  3367→\n  3368→    /// Where the container is stored. This is calculated as part of compile if m_containerFormat is\n  3369→    /// set to a supported format.\n  3370→    ComPtr<IArtifact> m_containerArtifact;\n  3371→    /// Holds the container as a file system\n  3372→    ComPtr<ISlangMutableFileSystem> m_containerFileSystem;\n  3373→\n  3374→    /// File system used by repro system if a file couldn't be found within the repro (or associated\n  3375→    /// directory)\n  3376→    ComPtr<ISlangFileSystem> m_reproFallbackFileSystem =\n  3377→        ComPtr<ISlangFileSystem>(OSFileSystem::getExtSingleton());\n  3378→\n  3379→    // Path to output container to\n  3380→    String m_containerOutputPath;\n  3381→\n  3382→    // Should we just pass the input to another compiler?\n  3383→    PassThroughMode m_passThrough = PassThroughMode::None;\n  3384→\n  3385→    /// If output should be source embedded, define the style of the embedding\n  3386→    SourceEmbedUtil::Style m_sourceEmbedStyle = SourceEmbedUtil::Style::None;\n  3387→    /// The language to be used for source embedding\n  3388→    SourceLanguage m_sourceEmbedLanguage = SourceLanguage::C;\n  3389→    /// Source embed variable name. Note may be used as a basis for names if multiple items written\n  3390→    String m_sourceEmbedName;\n  3391→\n  3392→    /// Source code for the specialization arguments to use for the global specialization parameters\n  3393→    /// of the program.\n  3394→    List<String> m_globalSpecializationArgStrings;\n  3395→\n  3396→    // Are we being driven by the command-line `slangc`, and should act accordingly?\n  3397→    bool m_isCommandLineCompile = false;\n  3398→\n  3399→    String m_diagnosticOutput;\n  3400→\n  3401→    /// A blob holding the diagnostic output\n  3402→    ComPtr<ISlangBlob> m_diagnosticOutputBlob;\n  3403→\n  3404→    /// Per-entry-point information not tracked by other compile requests\n  3405→    class EntryPointInfo : public RefObject\n  3406→    {\n  3407→    public:\n  3408→        /// Source code for the specialization arguments to use for the specialization parameters of\n  3409→        /// the entry point.\n  3410→        List<String> specializationArgStrings;\n  3411→    };\n  3412→    List<EntryPointInfo> m_entryPoints;\n  3413→\n  3414→    /// Per-target information only needed for command-line compiles\n  3415→    class TargetInfo : public RefObject\n  3416→    {\n  3417→    public:\n  3418→        // Requested output paths for each entry point.\n  3419→        // An empty string indices no output desired for\n  3420→        // the given entry point.\n  3421→        Dictionary<Int, String> entryPointOutputPaths;\n  3422→        String wholeTargetOutputPath;\n  3423→        CompilerOptionSet targetOptions;\n  3424→    };\n  3425→    Dictionary<TargetRequest*, RefPtr<TargetInfo>> m_targetInfos;\n  3426→\n  3427→    CompilerOptionSet m_optionSetForDefaultTarget;\n  3428→\n  3429→    CompilerOptionSet& getTargetOptionSet(TargetRequest* req);\n  3430→\n  3431→    CompilerOptionSet& getTargetOptionSet(Index targetIndex);\n  3432→\n  3433→    String m_dependencyOutputPath;\n  3434→\n  3435→    /// Writes the modules in a container to the stream\n  3436→    SlangResult writeContainerToStream(Stream* stream);\n  3437→\n  3438→    /// If a container format has been specified produce a container (stored in m_containerBlob)\n  3439→    SlangResult maybeCreateContainer();\n  3440→    /// If a container has been constructed and the filename/path has contents will try to write\n  3441→    /// the container contents to the file\n  3442→    SlangResult maybeWriteContainer(const String& fileName);\n  3443→\n  3444→    Linkage* getLinkage() { return m_linkage; }\n  3445→\n  3446→    int addEntryPoint(\n  3447→        int translationUnitIndex,\n  3448→        String const& name,\n  3449→        Profile profile,\n  3450→        List<String> const& genericTypeNames);\n  3451→\n  3452→    void setWriter(WriterChannel chan, ISlangWriter* writer);\n  3453→    ISlangWriter* getWriter(WriterChannel chan) const\n  3454→    {\n  3455→        return m_writers->getWriter(SlangWriterChannel(chan));\n  3456→    }\n  3457→\n  3458→    /// The end to end request can be passed as nullptr, if not driven by one\n  3459→    SlangResult executeActionsInner();\n  3460→    SlangResult executeActions();\n  3461→\n  3462→    Session* getSession() { return m_session; }\n  3463→    DiagnosticSink* getSink() { return &m_sink; }\n  3464→    NamePool* getNamePool() { return getLinkage()->getNamePool(); }\n  3465→\n  3466→    FrontEndCompileRequest* getFrontEndReq() { return m_frontEndReq; }\n  3467→\n  3468→    ComponentType* getUnspecializedGlobalComponentType()\n  3469→    {\n  3470→        return getFrontEndReq()->getGlobalComponentType();\n  3471→    }\n  3472→    ComponentType* getUnspecializedGlobalAndEntryPointsComponentType()\n  3473→    {\n  3474→        return getFrontEndReq()->getGlobalAndEntryPointsComponentType();\n  3475→    }\n  3476→\n  3477→    ComponentType* getSpecializedGlobalComponentType() { return m_specializedGlobalComponentType; }\n  3478→    ComponentType* getSpecializedGlobalAndEntryPointsComponentType()\n  3479→    {\n  3480→        return m_specializedGlobalAndEntryPointsComponentType;\n  3481→    }\n  3482→\n  3483→    ComponentType* getSpecializedEntryPointComponentType(Index index)\n  3484→    {\n  3485→        return m_specializedEntryPoints[index];\n  3486→    }\n  3487→\n  3488→    void writeArtifactToStandardOutput(IArtifact* artifact, DiagnosticSink* sink);\n  3489→\n  3490→    void generateOutput();\n  3491→\n  3492→    CompilerOptionSet& getOptionSet() { return m_linkage->m_optionSet; }\n  3493→\n  3494→private:\n  3495→    String _getWholeProgramPath(TargetRequest* targetReq);\n  3496→    String _getEntryPointPath(TargetRequest* targetReq, Index entryPointIndex);\n  3497→\n  3498→    /// Maybe write the artifact to the path (if set), or stdout (if there is no container or path)\n  3499→    SlangResult _maybeWriteArtifact(const String& path, IArtifact* artifact);\n  3500→    SlangResult _maybeWriteDebugArtifact(\n  3501→        TargetProgram* targetProgram,\n  3502→        const String& path,\n  3503→        IArtifact* artifact);\n  3504→    SlangResult _writeArtifact(const String& path, IArtifact* artifact);\n  3505→\n  3506→    /// Adds any extra settings to complete a targetRequest\n  3507→    void _completeTargetRequest(UInt targetIndex);\n  3508→\n  3509→    ISlangUnknown* getInterface(const Guid& guid);\n  3510→\n  3511→    void generateOutput(ComponentType* program);\n  3512→    void generateOutput(TargetProgram* targetProgram);\n  3513→\n  3514→    void init();\n  3515→\n  3516→    Session* m_session = nullptr;\n  3517→    RefPtr<Linkage> m_linkage;\n  3518→    DiagnosticSink m_sink;\n  3519→    RefPtr<FrontEndCompileRequest> m_frontEndReq;\n  3520→    RefPtr<ComponentType> m_specializedGlobalComponentType;\n  3521→    RefPtr<ComponentType> m_specializedGlobalAndEntryPointsComponentType;\n  3522→    List<RefPtr<ComponentType>> m_specializedEntryPoints;\n  3523→\n  3524→    // For output\n  3525→\n  3526→    RefPtr<StdWriters> m_writers;\n  3527→};\n  3528→\n  3529→/* Returns SLANG_OK if pass through support is available */\n  3530→SlangResult checkExternalCompilerSupport(Session* session, PassThroughMode passThrough);\n  3531→/* Report an error appearing from external compiler to the diagnostic sink error to the diagnostic\n  3532→sink.\n  3533→@param compilerName The name of the compiler the error came for (or nullptr if not known)\n  3534→@param res Result associated with the error. The error code will be reported. (Can take HRESULT -\n  3535→and will expand to string if known)\n  3536→@param diagnostic The diagnostic string associated with the compile failure\n  3537→@param sink The diagnostic sink to report to */\n  3538→void reportExternalCompileError(\n  3539→    const char* compilerName,\n  3540→    SlangResult res,\n  3541→    const UnownedStringSlice& diagnostic,\n  3542→    DiagnosticSink* sink);\n  3543→\n  3544→//\n  3545→\n  3546→// Information about BaseType that's useful for checking literals\n  3547→struct BaseTypeInfo\n  3548→{\n  3549→    typedef uint8_t Flags;\n  3550→    struct Flag\n  3551→    {\n  3552→        enum Enum : Flags\n  3553→        {\n  3554→            Signed = 0x1,\n  3555→            FloatingPoint = 0x2,\n  3556→            Integer = 0x4,\n  3557→        };\n  3558→    };\n  3559→\n  3560→    SLANG_FORCE_INLINE static const BaseTypeInfo& getInfo(BaseType baseType)\n  3561→    {\n  3562→        return s_info[Index(baseType)];\n  3563→    }\n  3564→\n  3565→    static UnownedStringSlice asText(BaseType baseType);\n  3566→\n  3567→    uint8_t sizeInBytes; ///< Size of type in bytes\n  3568→    Flags flags;\n  3569→    uint8_t baseType;\n  3570→\n  3571→    static bool check();\n  3572→\n  3573→private:\n  3574→    static const BaseTypeInfo s_info[Index(BaseType::CountOf)];\n  3575→};\n  3576→\n  3577→class CodeGenTransitionMap\n  3578→{\n  3579→public:\n  3580→    struct Pair\n  3581→    {\n  3582→        typedef Pair ThisType;\n  3583→        SLANG_FORCE_INLINE bool operator==(const ThisType& rhs) const\n  3584→        {\n  3585→            return source == rhs.source && target == rhs.target;\n  3586→        }\n  3587→        SLANG_FORCE_INLINE bool operator!=(const ThisType& rhs) const { return !(*this == rhs); }\n  3588→\n  3589→        SLANG_FORCE_INLINE HashCode getHashCode() const\n  3590→        {\n  3591→            return combineHash(HashCode(source), HashCode(target));\n  3592→        }\n  3593→\n  3594→        CodeGenTarget source;\n  3595→        CodeGenTarget target;\n  3596→    };\n  3597→\n  3598→    void removeTransition(CodeGenTarget source, CodeGenTarget target)\n  3599→    {\n  3600→        m_map.remove(Pair{source, target});\n  3601→    }\n  3602→    void addTransition(CodeGenTarget source, CodeGenTarget target, PassThroughMode compiler)\n  3603→    {\n  3604→        SLANG_ASSERT(source != target);\n  3605→        m_map.set(Pair{source, target}, compiler);\n  3606→    }\n  3607→    bool hasTransition(CodeGenTarget source, CodeGenTarget target) const\n  3608→    {\n  3609→        return m_map.containsKey(Pair{source, target});\n  3610→    }\n  3611→    PassThroughMode getTransition(CodeGenTarget source, CodeGenTarget target) const\n  3612→    {\n  3613→        const Pair pair{source, target};\n  3614→        auto value = m_map.tryGetValue(pair);\n  3615→        return value ? *value : PassThroughMode::None;\n  3616→    }\n  3617→\n  3618→protected:\n  3619→    Dictionary<Pair, PassThroughMode> m_map;\n  3620→};\n  3621→\n  3622→class Session : public RefObject, public slang::IGlobalSession\n  3623→{\n  3624→public:\n  3625→    SLANG_COM_INTERFACE(\n  3626→        0xd6b767eb,\n  3627→        0xd786,\n  3628→        0x4343,\n  3629→        {0x2a, 0x8c, 0x6d, 0xa0, 0x3d, 0x5a, 0xb4, 0x4a})\n  3630→\n  3631→    SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject)\n  3632→        SLANG_OVERRIDE;\n  3633→    SLANG_REF_OBJECT_IUNKNOWN_ADD_REF\n  3634→    SLANG_REF_OBJECT_IUNKNOWN_RELEASE\n  3635→\n  3636→    // slang::IGlobalSession\n  3637→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3638→    createSession(slang::SessionDesc const& desc, slang::ISession** outSession) override;\n  3639→    SLANG_NO_THROW SlangProfileID SLANG_MCALL findProfile(char const* name) override;\n  3640→    SLANG_NO_THROW void SLANG_MCALL\n  3641→    setDownstreamCompilerPath(SlangPassThrough passThrough, char const* path) override;\n  3642→    SLANG_NO_THROW void SLANG_MCALL\n  3643→    setDownstreamCompilerPrelude(SlangPassThrough inPassThrough, char const* prelude) override;\n  3644→    SLANG_NO_THROW void SLANG_MCALL\n  3645→    getDownstreamCompilerPrelude(SlangPassThrough inPassThrough, ISlangBlob** outPrelude) override;\n  3646→    SLANG_NO_THROW const char* SLANG_MCALL getBuildTagString() override;\n  3647→    SLANG_NO_THROW SlangResult SLANG_MCALL setDefaultDownstreamCompiler(\n  3648→        SlangSourceLanguage sourceLanguage,\n  3649→        SlangPassThrough defaultCompiler) override;\n  3650→    SLANG_NO_THROW SlangPassThrough SLANG_MCALL\n  3651→    getDefaultDownstreamCompiler(SlangSourceLanguage sourceLanguage) override;\n  3652→\n  3653→    SLANG_NO_THROW void SLANG_MCALL\n  3654→    setLanguagePrelude(SlangSourceLanguage inSourceLanguage, char const* prelude) override;\n  3655→    SLANG_NO_THROW void SLANG_MCALL\n  3656→    getLanguagePrelude(SlangSourceLanguage inSourceLanguage, ISlangBlob** outPrelude) override;\n  3657→\n  3658→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3659→    createCompileRequest(slang::ICompileRequest** outCompileRequest) override;\n  3660→\n  3661→    SLANG_NO_THROW void SLANG_MCALL\n  3662→    addBuiltins(char const* sourcePath, char const* sourceString) override;\n  3663→    SLANG_NO_THROW void SLANG_MCALL\n  3664→    setSharedLibraryLoader(ISlangSharedLibraryLoader* loader) override;\n  3665→    SLANG_NO_THROW ISlangSharedLibraryLoader* SLANG_MCALL getSharedLibraryLoader() override;\n  3666→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3667→    checkCompileTargetSupport(SlangCompileTarget target) override;\n  3668→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3669→    checkPassThroughSupport(SlangPassThrough passThrough) override;\n  3670→\n  3671→    void writeCoreModuleDoc(String config);\n  3672→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3673→    compileCoreModule(slang::CompileCoreModuleFlags flags) override;\n  3674→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3675→    loadCoreModule(const void* coreModule, size_t coreModuleSizeInBytes) override;\n  3676→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3677→    saveCoreModule(SlangArchiveType archiveType, ISlangBlob** outBlob) override;\n  3678→\n  3679→    SLANG_NO_THROW SlangResult SLANG_MCALL compileBuiltinModule(\n  3680→        slang::BuiltinModuleName moduleName,\n  3681→        slang::CompileCoreModuleFlags flags) override;\n  3682→    SLANG_NO_THROW SlangResult SLANG_MCALL loadBuiltinModule(\n  3683→        slang::BuiltinModuleName moduleName,\n  3684→        const void* coreModule,\n  3685→        size_t coreModuleSizeInBytes) override;\n  3686→    SLANG_NO_THROW SlangResult SLANG_MCALL saveBuiltinModule(\n  3687→        slang::BuiltinModuleName moduleName,\n  3688→        SlangArchiveType archiveType,\n  3689→        ISlangBlob** outBlob) override;\n  3690→\n  3691→    SLANG_NO_THROW SlangCapabilityID SLANG_MCALL findCapability(char const* name) override;\n  3692→\n  3693→    SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerForTransition(\n  3694→        SlangCompileTarget source,\n  3695→        SlangCompileTarget target,\n  3696→        SlangPassThrough compiler) override;\n  3697→    SLANG_NO_THROW SlangPassThrough SLANG_MCALL getDownstreamCompilerForTransition(\n  3698→        SlangCompileTarget source,\n  3699→        SlangCompileTarget target) override;\n  3700→    SLANG_NO_THROW void SLANG_MCALL\n  3701→    getCompilerElapsedTime(double* outTotalTime, double* outDownstreamTime) override\n  3702→    {\n  3703→        *outDownstreamTime = m_downstreamCompileTime;\n  3704→        *outTotalTime = m_totalCompileTime;\n  3705→    }\n  3706→\n  3707→    SLANG_NO_THROW SlangResult SLANG_MCALL setSPIRVCoreGrammar(char const* jsonPath) override;\n  3708→\n  3709→    SLANG_NO_THROW SlangResult SLANG_MCALL parseCommandLineArguments(\n  3710→        int argc,\n  3711→        const char* const* argv,\n  3712→        slang::SessionDesc* outSessionDesc,\n  3713→        ISlangUnknown** outAllocation) override;\n  3714→\n  3715→    SLANG_NO_THROW SlangResult SLANG_MCALL\n  3716→    getSessionDescDigest(slang::SessionDesc* sessionDesc, ISlangBlob** outBlob) override;\n  3717→\n  3718→    /// Get the downstream compiler for a transition\n  3719→    IDownstreamCompiler* getDownstreamCompiler(CodeGenTarget source, CodeGenTarget target);\n  3720→\n  3721→    // This needs to be atomic not because of contention between threads as `Session` is\n  3722→    // *not* multithreaded, but can be used exclusively on one thread at a time.\n  3723→    // The need for atomic is purely for visibility. If the session is used on a different\n  3724→    // thread we need to be sure any changes to m_epochId are visible to this thread.\n  3725→    std::atomic<Index> m_epochId = 1;\n  3726→\n  3727→    Scope* baseLanguageScope = nullptr;\n  3728→    Scope* coreLanguageScope = nullptr;\n  3729→    Scope* hlslLanguageScope = nullptr;\n  3730→    Scope* slangLanguageScope = nullptr;\n  3731→    Scope* glslLanguageScope = nullptr;\n  3732→    Name* glslModuleName = nullptr;\n  3733→\n  3734→    ModuleDecl* baseModuleDecl = nullptr;\n  3735→    List<RefPtr<Module>> coreModules;\n  3736→\n  3737→    SourceManager builtinSourceManager;\n  3738→\n  3739→    SourceManager* getBuiltinSourceManager() { return &builtinSourceManager; }\n  3740→\n  3741→    // Name pool stuff for unique-ing identifiers\n  3742→\n  3743→    RootNamePool rootNamePool;\n  3744→    NamePool namePool;\n  3745→\n  3746→    RootNamePool* getRootNamePool() { return &rootNamePool; }\n  3747→    NamePool* getNamePool() { return &namePool; }\n  3748→    Name* getNameObj(String name) { return namePool.getName(name); }\n  3749→    Name* tryGetNameObj(String name) { return namePool.tryGetName(name); }\n  3750→    //\n  3751→\n  3752→    /// This AST Builder should only be used for creating AST nodes that are global across requests\n  3753→    /// not doing so could lead to memory being consumed but not used.\n  3754→    ASTBuilder* getGlobalASTBuilder() { return globalAstBuilder; }\n  3755→    void finalizeSharedASTBuilder();\n  3756→\n  3757→    RefPtr<ASTBuilder> globalAstBuilder;\n  3758→\n  3759→    // Generated code for core module, etc.\n  3760→    String coreModulePath;\n  3761→\n  3762→    ComPtr<ISlangBlob> coreLibraryCode;\n  3763→    // ComPtr<ISlangBlob> slangLibraryCode;\n  3764→    ComPtr<ISlangBlob> hlslLibraryCode;\n  3765→    ComPtr<ISlangBlob> glslLibraryCode;\n  3766→    ComPtr<ISlangBlob> autodiffLibraryCode;\n  3767→\n  3768→    String getCoreModulePath();\n  3769→\n  3770→    ComPtr<ISlangBlob> getCoreLibraryCode();\n  3771→    ComPtr<ISlangBlob> getHLSLLibraryCode();\n  3772→    ComPtr<ISlangBlob> getAutodiffLibraryCode();\n  3773→    ComPtr<ISlangBlob> getGLSLLibraryCode();\n  3774→\n  3775→    void getBuiltinModuleSource(StringBuilder& sb, slang::BuiltinModuleName moduleName);\n  3776→\n  3777→    RefPtr<SharedASTBuilder> m_sharedASTBuilder;\n  3778→\n  3779→    SPIRVCoreGrammarInfo& getSPIRVCoreGrammarInfo()\n  3780→    {\n  3781→        if (!spirvCoreGrammarInfo)\n  3782→            setSPIRVCoreGrammar(nullptr);\n  3783→        SLANG_ASSERT(spirvCoreGrammarInfo);\n  3784→        return *spirvCoreGrammarInfo;\n  3785→    }\n  3786→    RefPtr<SPIRVCoreGrammarInfo> spirvCoreGrammarInfo;\n  3787→\n  3788→    //\n  3789→\n  3790→    void _setSharedLibraryLoader(ISlangSharedLibraryLoader* loader);\n  3791→\n  3792→    /// Will try to load the library by specified name (using the set loader), if not one already\n  3793→    /// available.\n  3794→    IDownstreamCompiler* getOrLoadDownstreamCompiler(PassThroughMode type, DiagnosticSink* sink);\n  3795→    /// Will unload the specified shared library if it's currently loaded\n  3796→    void resetDownstreamCompiler(PassThroughMode type);\n  3797→\n  3798→    /// Get the prelude associated with the language\n  3799→    const String& getPreludeForLanguage(SourceLanguage language)\n  3800→    {\n  3801→        return m_languagePreludes[int(language)];\n  3802→    }\n  3803→\n  3804→    /// Get the built in linkage -> handy to get the core module from\n  3805→    Linkage* getBuiltinLinkage() const { return m_builtinLinkage; }\n  3806→\n  3807→    Module* getBuiltinModule(slang::BuiltinModuleName builtinModuleName);\n  3808→\n  3809→    Name* getCompletionRequestTokenName() const { return m_completionTokenName; }\n  3810→\n  3811→    void init();\n  3812→\n  3813→    void addBuiltinSource(\n  3814→        Scope* scope,\n  3815→        String const& path,\n  3816→        ISlangBlob* sourceBlob,\n  3817→        Module*& outModule);\n  3818→    ~Session();\n  3819→\n  3820→    void addDownstreamCompileTime(double time) { m_downstreamCompileTime += time; }\n  3821→    void addTotalCompileTime(double time) { m_totalCompileTime += time; }\n  3822→\n  3823→    ComPtr<ISlangSharedLibraryLoader>\n  3824→        m_sharedLibraryLoader; ///< The shared library loader (never null)\n  3825→\n  3826→    int m_downstreamCompilerInitialized = 0;\n  3827→\n  3828→    RefPtr<DownstreamCompilerSet>\n  3829→        m_downstreamCompilerSet; ///< Information about all available downstream compilers.\n  3830→    ComPtr<IDownstreamCompiler> m_downstreamCompilers[int(\n  3831→        PassThroughMode::CountOf)]; ///< A downstream compiler for a pass through\n  3832→    DownstreamCompilerLocatorFunc m_downstreamCompilerLocators[int(PassThroughMode::CountOf)];\n  3833→    Name* m_completionTokenName = nullptr; ///< The name of a completion request token.\n  3834→\n  3835→    /// For parsing command line options\n  3836→    CommandOptions m_commandOptions;\n  3837→\n  3838→    int m_typeDictionarySize = 0;\n  3839→\n  3840→    RefPtr<RefObject> m_typeCheckingCache;\n  3841→    TypeCheckingCache* getTypeCheckingCache();\n  3842→    std::mutex m_typeCheckingCacheMutex;\n  3843→\n  3844→private:\n  3845→    struct BuiltinModuleInfo\n  3846→    {\n  3847→        const char* name;\n  3848→        Scope* languageScope;\n  3849→    };\n  3850→\n  3851→    BuiltinModuleInfo getBuiltinModuleInfo(slang::BuiltinModuleName name);\n  3852→\n  3853→    void _initCodeGenTransitionMap();\n  3854→\n  3855→    SlangResult _readBuiltinModule(\n  3856→        ISlangFileSystem* fileSystem,\n  3857→        Scope* scope,\n  3858→        String moduleName,\n  3859→        Module*& outModule);\n  3860→\n  3861→    SlangResult _loadRequest(EndToEndCompileRequest* request, const void* data, size_t size);\n  3862→\n  3863→    /// Linkage used for all built-in (core module) code.\n  3864→    RefPtr<Linkage> m_builtinLinkage;\n  3865→\n  3866→    String\n  3867→        m_downstreamCompilerPaths[int(PassThroughMode::CountOf)]; ///< Paths for each pass through\n  3868→    String m_languagePreludes[int(SourceLanguage::CountOf)]; ///< Prelude for each source language\n  3869→    PassThroughMode m_defaultDownstreamCompilers[int(SourceLanguage::CountOf)];\n  3870→\n  3871→    // Describes a conversion from one code gen target (source) to another (target)\n  3872→    CodeGenTransitionMap m_codeGenTransitionMap;\n  3873→\n  3874→    double m_downstreamCompileTime = 0.0;\n  3875→    double m_totalCompileTime = 0.0;\n  3876→};\n  3877→\n  3878→const char* getBuiltinModuleNameStr(slang::BuiltinModuleName name);\n  3879→\n  3880→void checkTranslationUnit(\n  3881→    TranslationUnitRequest* translationUnit,\n  3882→    LoadedModuleDictionary& loadedModules);\n  3883→\n  3884→// Look for a module that matches the given name:\n  3885→// either one we've loaded already, or one we\n  3886→// can find vai the search paths available to us.\n  3887→//\n  3888→// Needed by import declaration checking.\n  3889→//\n  3890→RefPtr<Module> findOrImportModule(\n  3891→    Linkage* linkage,\n  3892→    Name* name,\n  3893→    SourceLoc const& loc,\n  3894→    DiagnosticSink* sink,\n  3895→    const LoadedModuleDictionary* additionalLoadedModules);\n  3896→\n  3897→SlangResult passthroughDownstreamDiagnostics(\n  3898→    DiagnosticSink* sink,\n  3899→    IDownstreamCompiler* compiler,\n  3900→    IArtifact* artifact);\n  3901→\n  3902→//\n  3903→// The following functions are utilties to convert between\n  3904→// matching \"external\" (public API) and \"internal\" (implementation)\n  3905→// types. They are favored over explicit casts because they\n  3906→// help avoid making incorrect conversions (e.g., when using\n  3907→// `reinterpret_cast` or C-style casts), and because they\n  3908→// abstract over the conversion required for each pair of types.\n  3909→//\n  3910→\n  3911→SLANG_FORCE_INLINE slang::IGlobalSession* asExternal(Session* session)\n  3912→{\n  3913→    return static_cast<slang::IGlobalSession*>(session);\n  3914→}\n  3915→\n  3916→SLANG_FORCE_INLINE ComPtr<Session> asInternal(slang::IGlobalSession* session)\n  3917→{\n  3918→    Slang::Session* internalSession = nullptr;\n  3919→    session->queryInterface(SLANG_IID_PPV_ARGS(&internalSession));\n  3920→    return ComPtr<Session>(INIT_ATTACH, static_cast<Session*>(internalSession));\n  3921→}\n  3922→\n  3923→SLANG_FORCE_INLINE slang::ISession* asExternal(Linkage* linkage)\n  3924→{\n  3925→    return static_cast<slang::ISession*>(linkage);\n  3926→}\n  3927→\n  3928→SLANG_FORCE_INLINE Module* asInternal(slang::IModule* module)\n  3929→{\n  3930→    return static_cast<Module*>(module);\n  3931→}\n  3932→\n  3933→SLANG_FORCE_INLINE slang::IModule* asExternal(Module* module)\n  3934→{\n  3935→    return static_cast<slang::IModule*>(module);\n  3936→}\n  3937→\n  3938→ComponentType* asInternal(slang::IComponentType* inComponentType);\n  3939→\n  3940→SLANG_FORCE_INLINE slang::IComponentType* asExternal(ComponentType* componentType)\n  3941→{\n  3942→    return static_cast<slang::IComponentType*>(componentType);\n  3943→}\n  3944→\n  3945→SLANG_FORCE_INLINE slang::ProgramLayout* asExternal(ProgramLayout* programLayout)\n  3946→{\n  3947→    return (slang::ProgramLayout*)programLayout;\n  3948→}\n  3949→\n  3950→SLANG_FORCE_INLINE Type* asInternal(slang::TypeReflection* type)\n  3951→{\n  3952→    return reinterpret_cast<Type*>(type);\n  3953→}\n  3954→\n  3955→SLANG_FORCE_INLINE slang::TypeReflection* asExternal(Type* type)\n  3956→{\n  3957→    return reinterpret_cast<slang::TypeReflection*>(type);\n  3958→}\n  3959→\n  3960→SLANG_FORCE_INLINE DeclRef<Decl> asInternal(slang::GenericReflection* generic)\n  3961→{\n  3962→    return DeclRef<Decl>(reinterpret_cast<DeclRefBase*>(generic));\n  3963→}\n  3964→\n  3965→SLANG_FORCE_INLINE slang::GenericReflection* asExternal(DeclRef<Decl> generic)\n  3966→{\n  3967→    return reinterpret_cast<slang::GenericReflection*>(generic.declRefBase);\n  3968→}\n  3969→\n  3970→SLANG_FORCE_INLINE TypeLayout* asInternal(slang::TypeLayoutReflection* type)\n  3971→{\n  3972→    return reinterpret_cast<TypeLayout*>(type);\n  3973→}\n  3974→\n  3975→SLANG_FORCE_INLINE slang::TypeLayoutReflection* asExternal(TypeLayout* type)\n  3976→{\n  3977→    return reinterpret_cast<slang::TypeLayoutReflection*>(type);\n  3978→}\n  3979→\n  3980→SLANG_FORCE_INLINE SlangCompileRequest* asExternal(EndToEndCompileRequest* request)\n  3981→{\n  3982→    return static_cast<SlangCompileRequest*>(request);\n  3983→}\n  3984→\n  3985→SLANG_FORCE_INLINE EndToEndCompileRequest* asInternal(SlangCompileRequest* request)\n  3986→{\n  3987→    // Converts to the internal type -- does a runtime type check through queryInterfae\n  3988→    SLANG_ASSERT(request);\n  3989→    EndToEndCompileRequest* endToEndRequest = nullptr;\n  3990→    // NOTE! We aren't using to access an interface, so *doesn't* return with a refcount\n  3991→    request->queryInterface(SLANG_IID_PPV_ARGS(&endToEndRequest));\n  3992→    SLANG_ASSERT(endToEndRequest);\n  3993→    return endToEndRequest;\n  3994→}\n  3995→\n  3996→SLANG_FORCE_INLINE SlangCompileTarget asExternal(CodeGenTarget target)\n  3997→{\n  3998→    return (SlangCompileTarget)target;\n  3999→}\n  4000→\n  4001→SLANG_FORCE_INLINE SlangSourceLanguage asExternal(SourceLanguage sourceLanguage)\n  4002→{\n  4003→    return (SlangSourceLanguage)sourceLanguage;\n  4004→}\n  4005→\n  4006→// helpers for error/warning reporting\n  4007→enum class DiagnosticCategory\n  4008→{\n  4009→    None = 0,\n  4010→    Capability = 1 << 0,\n  4011→};\n  4012→template<typename P, typename... Args>\n  4013→bool maybeDiagnose(\n  4014→    DiagnosticSink* sink,\n  4015→    CompilerOptionSet& optionSet,\n  4016→    DiagnosticCategory errorType,\n  4017→    P const& pos,\n  4018→    DiagnosticInfo const& info,\n  4019→    Args const&... args)\n  4020→{\n  4021→    if ((int)errorType & (int)DiagnosticCategory::Capability &&\n  4022→        optionSet.getBoolOption(CompilerOptionName::IgnoreCapabilities))\n  4023→        return false;\n  4024→    return sink->diagnose(pos, info, args...);\n  4025→}\n  4026→\n  4027→template<typename P, typename... Args>\n  4028→bool maybeDiagnoseWarningOrError(\n  4029→    DiagnosticSink* sink,\n  4030→    CompilerOptionSet& optionSet,\n  4031→    DiagnosticCategory errorType,\n  4032→    P const& pos,\n  4033→    DiagnosticInfo const& warningInfo,\n  4034→    DiagnosticInfo const& errorInfo,\n  4035→    Args const&... args)\n  4036→{\n  4037→    if ((int)errorType & (int)DiagnosticCategory::Capability &&\n  4038→        optionSet.getBoolOption(CompilerOptionName::RestrictiveCapabilityCheck))\n  4039→    {\n  4040→        return maybeDiagnose(sink, optionSet, errorType, pos, errorInfo, args...);\n  4041→    }\n  4042→    else\n  4043→    {\n  4044→        return maybeDiagnose(sink, optionSet, errorType, pos, warningInfo, args...);\n  4045→    }\n  4046→}\n  4047→\n  4048→bool isValidSlangLanguageVersion(SlangLanguageVersion version);\n  4049→bool isValidGLSLVersion(int version);\n  4050→\n  4051→} // namespace Slang\n  4052→\n  4053→#endif\n  4054→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01XSEpyK3Z4QWQT1TY5DHEsC","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Perfect! Now I can see the class definition. I can see that on line 2622 there's the definition:\n\n```cpp\nclass Session : public RefObject, public slang::IGlobalSession\n```\n\nThis is the `Slang::Session` class that needs to be renamed to `Slang::GlobalSession`. I can also see that this is likely the main class that implements the IGlobalSession interface from the public API.\n\nLet me get a better understanding of the full scope by searching for all occurrences in the headers and implementation files.","signature":"EqIFCkgIBRABGAIqQIg/Ml9X8pXbwkMG6UBaM6bVEgj/5F23X+Ymt8YuNo7nETHXh9yKSde0JXIkyVBy/EE78R5+bp+S0Wnjb0gPICQSDLaXrAI6fxn3S6/rzRoMgfZxd1AAAkKla6APIjClsoYrMQPujWCqxZMM3Yh0HtmHRaSx9dcmRtJMW1FfsPLDfAE1Hoa8ai1/F4tu8dwqhwSl14DyxZFDiJnLa1Uzxtu5GqDoRR//jH/22sShsqHKzN3YhUoobs7vtA/4Ms4YZFMazei2cfjCpii/kW+FsWLqn3AJK89e5Fa82Oeny2k80ltC5W43dH5/FfSjOCSYQjcoj//UZfwSrFfPARTKXcg/J/5c87h1mtVWSDkKoMqjp2r3j9pyB9DD+Mfblk0rYLg0qlx1OHivIc8gejCORFidhpriWobahMXRZDnHB8am/FZiQq59fzH+o5xscLv9Jzv9qN/QyuYPoKFYs2wFkHkz6IGfuR0ZCezo4l0LTxXmyLTatlmeDVVdXSpnxn33ICPewvhfoapIn029SM6gQZARvHOLMINhcQFOZRUuOAsVPBXszJAw8T6qAOFHs0wX3hTkWIV2k4FEgGMYRAyy/fDxAxfjXOhgr8XQJAQOSxZ0aXO86iQRu7VADNQhkXXixv6A6qsptznjDqcHECnahuL7ISDYhb8YB9JekEoXb8yp+IpXVa4xjHmZAFrqZTWS7i5FS9dkmKpM06WypKnyARsMcQtBKiWY+2UlajSeOOxAnwJEycx9tV2es5sw/Ptt0aK+mzihlJUh/zjMU3zBQIn3P1QnB1aGh8Nck+SNLWgZEhSzAx6GwsapT129ToPfx4KYnZGYVgHfIUKF1XVCKw7B4t6lJn8AZid2TGf/6obsKeiH7F9HVcAYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":62548,"cache_read_input_tokens":26210,"output_tokens":2}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01XSEpyK3Z4QWQT1TY5DHEsC","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01ERHPCGmToeThoG3qUS4LDX","name":"mcp__github_comment__update_claude_comment","input":{"body":"Working on implementing the `Slang::Session` → `Slang::GlobalSession` renaming <img src=\"https://github.com/user-attachments/assets/5ac382c7-e004-429b-8e35-7feb3e8f9c6f\" width=\"14px\" height=\"14px\" style=\"vertical-align: middle; margin-left: 4px;\" />\n\n### Task List\n- [x] Analyze codebase structure and find all `Slang::Session` references\n- [ ] Rename the class `Slang::Session` to `Slang::GlobalSession` in header files\n- [ ] Update all references to the class name in implementation files  \n- [ ] Rename variables from `session` to `globalSession` where appropriate\n- [ ] Rename accessor methods from `getSession()` to `getGlobalSession()` etc.\n- [ ] Update comments and documentation\n- [ ] Verify build still works\n- [ ] Run formatting script\n- [ ] Commit and push changes\n- [ ] Create PR link\n\nI found the main class definition at line 2622 in `/home/runner/work/slang/slang/source/slang/slang-compiler.h`:\n\n```cpp\nclass Session : public RefObject, public slang::IGlobalSession\n```\n\nThis appears to be the implementation of the `slang::IGlobalSession` public API interface. I also found 60 files that reference `Slang::Session`, so this will be a comprehensive refactoring task.\n\n---\n[View job run](https://github.com/shader-slang/slang/actions/runs/16329805070)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":62548,"cache_read_input_tokens":26210,"output_tokens":569}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01ERHPCGmToeThoG3qUS4LDX","type":"tool_result","content":[{"type":"text","text":"{\n  \"id\": 3080606462,\n  \"html_url\": \"https://github.com/shader-slang/slang/issues/7793#issuecomment-3080606462\",\n  \"updated_at\": \"2025-07-16T20:56:15Z\"\n}"}]}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_019yEQzHCFq5JAHvYgjNUKLV","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me now search more specifically for the class Session definition and usage patterns. I need to understand how variables and methods are named throughout the codebase.","signature":"EtcCCkgIBRABGAIqQPZoyWenHxJ+ckvuScBYJ7VCVoZUx4L108R2YZsDedn1zg2tc2D/CpDxeokjIYbJSf0AvLKq9XJVt6HnHLEJiVoSDKu1IDLUcDmY979gFRoMPZpcqhUkF8jZrH+fIjDxHJWJtfrBGuBXYMF6fmZpeyhftViPoAJ/shCmH/ZOsyq2oPDwyTAocMeTTMorZd0qvAEJLGKXCFfQT3D0KOG+zOnwbQj6jMCnl4ehcN/w15rZfjYAvykpgYXVzpm8prCT94ddINSdm0mHfar1nsQKZzcWpu/OoKjDKaHQFSWU422E8iiWBfWf2qSbHuauD24sfWFTJ905+qeBWD6xC//9APl+tRcR8W2ECI/usUAWhbmL41XCC24i/o+FRrmbRziw/1U6RKX5sgiJeAuRu10cXzgnvB+FwB6616qLB8YoBlhwP2PFnaLqLTsmbG16eRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":65881,"cache_read_input_tokens":23536,"output_tokens":2}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_019yEQzHCFq5JAHvYgjNUKLV","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01HhsAfCs2TX1kEwHZnLwr8T","name":"Grep","input":{"pattern":"getSession\\(\\)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":65881,"cache_read_input_tokens":23536,"output_tokens":95}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01HhsAfCs2TX1kEwHZnLwr8T","type":"tool_result","content":"Found 59 files\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/shader.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-device.cpp\n/home/runner/work/slang/slang/tools/slang-test/slang-test-main.cpp\n/home/runner/work/slang/slang/tools/slang-test/test-context.h\n/home/runner/work/slang/slang/tools/render-test/render-test-main.cpp\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/open-gl/render-gl.cpp\n/home/runner/work/slang/slang/tools/gfx/renderer-shared.cpp\n/home/runner/work/slang/slang/tools/gfx/metal/metal-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-device.cpp\n/home/runner/work/slang/slang/source/slang/slang.cpp\n/home/runner/work/slang/slang/source/slang/slang-parser.cpp\n/home/runner/work/slang/slang/source/slang/slang-options.cpp\n/home/runner/work/slang/slang/source/slang/slang-lower-to-ir.cpp\n/home/runner/work/slang/slang/source/slang/slang-lookup.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir.h\n/home/runner/work/slang/slang/source/slang/slang-ir-spirv-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-ir-link.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-legalize-types.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-insts.h\n/home/runner/work/slang/slang/source/slang/slang-ir-constexpr.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-deduplicate.cpp\n/home/runner/work/slang/slang/source/slang/slang-emit.cpp\n/home/runner/work/slang/slang/source/slang/slang-emit-spirv.cpp\n/home/runner/work/slang/slang/source/slang/slang-emit-c-like.h\n/home/runner/work/slang/slang/source/slang/slang-compiler.cpp\n/home/runner/work/slang/slang/source/slang/slang-compiler.h\n/home/runner/work/slang/slang/source/slang/slang-check-stmt.cpp\n/home/runner/work/slang/slang/source/slang/slang-check-impl.h\n/home/runner/work/slang/slang/source/slang/slang-check-inheritance.cpp\n/home/runner/work/slang/slang/source/slang/slang-check-modifier.cpp\n/home/runner/work/slang/slang/source/slang/slang-check-decl.cpp\n/home/runner/work/slang/slang/source/slang/slang-check-expr.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-entrypoint.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-module.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-type-conformance.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-component-type.cpp\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-component-type.h\n/home/runner/work/slang/slang/include/slang.h"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_0145t6VVXhZGvo1UQK329D9f","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Great! I can see a lot of `getSession()` methods. Let me also search for variables that might need renaming. Let me search for specific patterns of variable usage.","signature":"EtACCkgIBRABGAIqQIuJdiMvFTwrxMq9V2fr2EYA+MI2o/LMYrlZRuIibZ9x3FcWl+a+1azRZw2zNGWXgYeRBNBUqxmVi96nzucogUUSDJ9u/RnMLCFFznQP5RoMsTu+jxMPw4aTdiqUIjAC83RoBFH3LY4GpLAHaCAX6Xr2ZejPcEtPeCWTfiNbfCmiReecejztQ31Se4D4VOgqtQGY0Ih+Az1FTBmt8fzYU2W8HmYrCk8R7fd0nYm/vwLeFIoIZApjgSYDKDnVjQ14T+1C0rTfAoz3pYolzYnLVEG2Tb0lxizfZbodK0nGlr8g7YZNRb3hWo1Gk0ECLLCLcIAji/fW3WjjlL3x8+SlNuw1nr/AmEZ5erLlzR/HY0EhUE5KZLSLM7n+fzox8PciSZgQ7r/EDluqf/pNx1N8gOLKcu0IfpOsyGD41+6XGUGorMtvEvzmGAE="}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":2582,"cache_read_input_tokens":88758,"output_tokens":99}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_0145t6VVXhZGvo1UQK329D9f","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01PXbFpfsNRrg4KXnYbq9dVL","name":"Grep","input":{"pattern":"->session"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":2582,"cache_read_input_tokens":88758,"output_tokens":99}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01PXbFpfsNRrg4KXnYbq9dVL","type":"tool_result","content":"No files found"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01CET1wEWj2ZKjUfQ33PDcxM","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me try different patterns to find variables that might need renaming.","signature":"EvMBCkgIBRABGAIqQAJg56g4J9lpjxOO0H/VoN9nLvQt54hUSpuBOJXyNLu4dwU1ZObcU+uPDHGSStQ2bPKYlTKa4gluZ46FMijt8LwSDL32MsJMOqrCkrrDpRoM3Jyp1fjxKPKv2e2IIjAlo9SuQW99kJC6igFSFIgUSUMWATG1K7hWlf18VkbUOwacQMe869Vb+xJtB2jfkfUqWSFRrzWtdntpMkMlhIgb3ONhfi6eDEt7tLALD/mcrh+Rqu5oAUHtSW4Qfc2DB/tVeXvaHi4ZphopcrTruuhv9Y+dOs0TafzOTVdyhwF4kYLa64Z4eJB2ugYlGAE="}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2044,"cache_read_input_tokens":89417,"output_tokens":84}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01CET1wEWj2ZKjUfQ33PDcxM","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01SJkxULFuQFoWM5dzasaDTG","name":"Grep","input":{"pattern":"\\ssession\\s*[=,]"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2044,"cache_read_input_tokens":89417,"output_tokens":84}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01SJkxULFuQFoWM5dzasaDTG","type":"tool_result","content":"Found 124 files\n/home/runner/work/slang/slang/external/vulkan/registry/validusage.json\n/home/runner/work/slang/slang/external/vulkan/include/vulkan/vulkan_raii.hpp\n/home/runner/work/slang/slang/external/vulkan/include/vulkan/vulkan_handles.hpp\n/home/runner/work/slang/slang/external/vulkan/include/vulkan/vulkan_funcs.hpp\n/home/runner/work/slang/slang/external/vulkan/include/vulkan/vulkan_core.h\n/home/runner/work/slang/slang/external/vulkan/include/vulkan/vulkan.hpp\n/home/runner/work/slang/slang/external/slang-rhi/tests/testing.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/shader-object.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/shader-object.h\n/home/runner/work/slang/slang/external/slang-rhi/src/shader.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/debug-layer/debug-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/debug-layer/debug-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-shader-object-layout.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-device.cpp\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-device.h\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-translation-unit-import.cpp\n/home/runner/work/slang/slang/tools/test-server/test-server-main.cpp\n/home/runner/work/slang/slang/tools/slang-unit-test/unit-test-find-type-by-name.cpp\n/home/runner/work/slang/slang/tools/slang-test/slang-test-main.cpp\n/home/runner/work/slang/slang/tools/slang-test/slangc-tool.h\n/home/runner/work/slang/slang/tools/slang-test/slangi-tool-impl.h\n/home/runner/work/slang/slang/tools/slang-test/slangi-tool.h\n/home/runner/work/slang/slang/tools/slang-reflection-test/slang-reflection-test-main.cpp\n/home/runner/work/slang/slang/tools/render-test/render-test-main.cpp\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-device.cpp\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-device.h\n/home/runner/work/slang/slang/tools/gfx/open-gl/render-gl.cpp\n/home/runner/work/slang/slang/tools/gfx/renderer-shared.cpp\n/home/runner/work/slang/slang/tools/gfx/renderer-shared.h\n/home/runner/work/slang/slang/tools/gfx/slang.slang\n/home/runner/work/slang/slang/tools/gfx/metal/metal-device.cpp\n/home/runner/work/slang/slang/tools/gfx/metal/metal-device.h\n/home/runner/work/slang/slang/tools/gfx/metal/metal-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/debug-layer/debug-device.cpp\n/home/runner/work/slang/slang/tools/gfx/debug-layer/debug-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-device.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-device.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-device.cpp\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-device.h\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-device.cpp\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-device.h\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-shader-object-layout.cpp\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-shader-object-layout.h\n/home/runner/work/slang/slang/tests/wasm/smoke/smoke-test.js\n/home/runner/work/slang/slang/source/slang/slang.cpp\n/home/runner/work/slang/slang/source/slang/slang-serialize-container.cpp\n/home/runner/work/slang/slang/source/slang/slang-serialize-container.h\n/home/runner/work/slang/slang/source/slang/slang-serialize-ir.cpp\n/home/runner/work/slang/slang/source/slang/slang-serialize-ir.h\n/home/runner/work/slang/slang/source/slang/slang-reflection-api.cpp\n/home/runner/work/slang/slang/source/slang/slang-parser.cpp\n/home/runner/work/slang/slang/source/slang/slang-options.cpp\n/home/runner/work/slang/slang/source/slang/slang-lower-to-ir.cpp\n/home/runner/work/slang/slang/source/slang/slang-language-server.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-link.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-legalize-types.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-glsl-legalize.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-glsl-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-ir-byte-address-legalize.cpp\n/home/runner/work/slang/slang/source/slang/slang-ir-byte-address-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-emit.cpp\n(Results are truncated. Consider using a more specific path or pattern.)"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01Uo7RktgNSB4La8p3Gh7gFb","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"This is too broad. Let me look more specifically at the compiler implementation files to understand the patterns better. Let me start by looking at the implementation file for the compiler.","signature":"EugCCkgIBRABGAIqQDeVbQ8VO4j85VxUxEaUfWkK6VP5xFZbfrSq0uiEkD6Kos1azaUZFkOeWL+46tNujmU9B8xWRVZg7wCoLZ1OuLYSDDNnI871VL1j+H4o+xoMLxp9L1vrp2KU2MHmIjDTYm6JgyaRGqDKE4Yezt0o3uvh9JCu92+T4jJxHONNJZTEQV8e2tjDmls5oayO8LYqzQG/u6ihr/W7BgiTPS/V3Ms/Ff0dHE3o5GbvLo1oLxmOL3JtDDbcDPH33lgSAp1PJo4m7LdFGhsYCmXWDgesmOtUbFfd8w2pw1c9kq8B4iIKn/373TQy+IeZomO1qWjTYuWTWaz2kO70aatBMNUB/+BOk7WfH912Y/XdFFYn8tUUBavWPbA7i7Kj3e8Vfwy5C2/0FQN3je1HqZnhxXiWs9r/w/kUUuHqd5PHPx+K0NMjQvtkk9U+FntCUaR4aL3AG5/6XmktIX6lVviD+IpxGAE="}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":3236,"cache_read_input_tokens":91461,"output_tokens":136}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01Uo7RktgNSB4La8p3Gh7gFb","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_017FaDbfdMkZ9rLtrWP3mPh6","name":"Read","input":{"file_path":"/home/runner/work/slang/slang/source/slang/slang-compiler.cpp","limit":100}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":3236,"cache_read_input_tokens":91461,"output_tokens":136}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_017FaDbfdMkZ9rLtrWP3mPh6","type":"tool_result","content":"     1→// Compiler.cpp : Defines the entry point for the console application.\n     2→//\n     3→#include \"slang-compiler.h\"\n     4→\n     5→#include \"../compiler-core/slang-lexer.h\"\n     6→#include \"../core/slang-basic.h\"\n     7→#include \"../core/slang-castable.h\"\n     8→#include \"../core/slang-hex-dump-util.h\"\n     9→#include \"../core/slang-io.h\"\n    10→#include \"../core/slang-performance-profiler.h\"\n    11→#include \"../core/slang-platform.h\"\n    12→#include \"../core/slang-riff.h\"\n    13→#include \"../core/slang-string-util.h\"\n    14→#include \"../core/slang-type-convert-util.h\"\n    15→#include \"../core/slang-type-text-util.h\"\n    16→#include \"slang-check-impl.h\"\n    17→#include \"slang-check.h\"\n    18→\n    19→#include <chrono>\n    20→\n    21→// Artifact\n    22→#include \"../compiler-core/slang-artifact-associated.h\"\n    23→#include \"../compiler-core/slang-artifact-container-util.h\"\n    24→#include \"../compiler-core/slang-artifact-desc-util.h\"\n    25→#include \"../compiler-core/slang-artifact-diagnostic-util.h\"\n    26→#include \"../compiler-core/slang-artifact-impl.h\"\n    27→#include \"../compiler-core/slang-artifact-representation-impl.h\"\n    28→#include \"../compiler-core/slang-artifact-util.h\"\n    29→\n    30→// Artifact output\n    31→#include \"slang-artifact-output-util.h\"\n    32→#include \"slang-emit-cuda.h\"\n    33→#include \"slang-extension-tracker.h\"\n    34→#include \"slang-lower-to-ir.h\"\n    35→#include \"slang-mangle.h\"\n    36→#include \"slang-parameter-binding.h\"\n    37→#include \"slang-parser.h\"\n    38→#include \"slang-preprocessor.h\"\n    39→#include \"slang-serialize-ast.h\"\n    40→#include \"slang-serialize-container.h\"\n    41→#include \"slang-type-layout.h\"\n    42→\n    43→namespace Slang\n    44→{\n    45→\n    46→// !!!!!!!!!!!!!!!!!!!!!! free functions for DiagnosicSink !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    47→\n    48→bool isHeterogeneousTarget(CodeGenTarget target)\n    49→{\n    50→    return ArtifactDescUtil::makeDescForCompileTarget(asExternal(target)).style ==\n    51→           ArtifactStyle::Host;\n    52→}\n    53→\n    54→void printDiagnosticArg(StringBuilder& sb, CodeGenTarget val)\n    55→{\n    56→    UnownedStringSlice name = TypeTextUtil::getCompileTargetName(asExternal(val));\n    57→    name = name.getLength() ? name : toSlice(\"<unknown>\");\n    58→    sb << name;\n    59→}\n    60→\n    61→void printDiagnosticArg(StringBuilder& sb, PassThroughMode val)\n    62→{\n    63→    sb << TypeTextUtil::getPassThroughName(SlangPassThrough(val));\n    64→}\n    65→\n    66→//\n    67→// FrontEndEntryPointRequest\n    68→//\n    69→\n    70→FrontEndEntryPointRequest::FrontEndEntryPointRequest(\n    71→    FrontEndCompileRequest* compileRequest,\n    72→    int translationUnitIndex,\n    73→    Name* name,\n    74→    Profile profile)\n    75→    : m_compileRequest(compileRequest)\n    76→    , m_translationUnitIndex(translationUnitIndex)\n    77→    , m_name(name)\n    78→    , m_profile(profile)\n    79→{\n    80→}\n    81→\n    82→\n    83→TranslationUnitRequest* FrontEndEntryPointRequest::getTranslationUnit()\n    84→{\n    85→    return getCompileRequest()->translationUnits[m_translationUnitIndex];\n    86→}\n    87→\n    88→//\n    89→// EntryPoint\n    90→//\n    91→\n    92→ISlangUnknown* EntryPoint::getInterface(const Guid& guid)\n    93→{\n    94→    if (guid == slang::IEntryPoint::getTypeGuid())\n    95→        return static_cast<slang::IEntryPoint*>(this);\n    96→\n    97→    return Super::getInterface(guid);\n    98→}\n    99→\n   100→RefPtr<EntryPoint> EntryPoint::create(\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01HmAWAJ48WqNyeRE6kXYf9n","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me get a better understanding by looking at how Session objects are used. Let me look at specific files that reference Session to understand the patterns.","signature":"EssCCkgIBRABGAIqQKTO6YBvLWqVVI6ox6tps4mPkIUY/D2SYIIqBSKrAHpYdfeE4ZoFCEVmIwL3OGY2U4IbM1d/gIGulWQE9hbJtKYSDEzCzlTL5hlZ7UMJbhoMT8Oj/e3n5sFQVEx+IjCqG0BePHgGVoPg9DQron0CsehujN7I6l7dchrjkHOt5WdMbpwaIA1s0nplZaHnit8qsAHsMnuSSj1Al6i44pO4gq1eStvMrPz9zN0VUdk8L4iaqeUhWA5Ue1Hxc4eGt6rYf0xFfCvR/pEXubZH5TfvYTxxGk+ZwqDWA4TrN0mlKpvdK8V1KPpiiK0adtXLSEzw12niTai91v3Mmyce3z46RvyXVkEkIjl5KPm/P9y2DZasOpUnRjWRH9y8jjGhcluw9D+4SAZo1miyMu3N6PUYRQKq+pBaUgnxtkoRkuX0+eQuChgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1515,"cache_read_input_tokens":94697,"output_tokens":149}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01HmAWAJ48WqNyeRE6kXYf9n","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01Uuk2TLy2PBQJMKWvRLBYb3","name":"Read","input":{"file_path":"/home/runner/work/slang/slang/source/slang/slang-compiler.cpp","offset":2000,"limit":100}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1515,"cache_read_input_tokens":94697,"output_tokens":149}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Uuk2TLy2PBQJMKWvRLBYb3","type":"tool_result","content":"  2000→            CodeGenContext intermediateContext(this, intermediateTarget);\n  2001→\n  2002→            ComPtr<IArtifact> intermediateArtifact;\n  2003→\n  2004→            SLANG_RETURN_ON_FAIL(intermediateContext._emitEntryPoints(intermediateArtifact));\n  2005→            intermediateContext.maybeDumpIntermediate(intermediateArtifact);\n  2006→\n  2007→            // Then disassemble the intermediate binary result to get the desired output\n  2008→            // Output the disassemble\n  2009→            ComPtr<IArtifact> disassemblyArtifact;\n  2010→            SLANG_RETURN_ON_FAIL(ArtifactOutputUtil::dissassembleWithDownstream(\n  2011→                getSession(),\n  2012→                intermediateArtifact,\n  2013→                getSink(),\n  2014→                disassemblyArtifact.writeRef()));\n  2015→\n  2016→            // Also disassemble the debug artifact if one exists.\n  2017→            auto debugArtifact = _getSeparateDbgArtifact(intermediateArtifact);\n  2018→            ComPtr<IArtifact> disassemblyDebugArtifact;\n  2019→            if (debugArtifact)\n  2020→            {\n  2021→                SLANG_RETURN_ON_FAIL(ArtifactOutputUtil::dissassembleWithDownstream(\n  2022→                    getSession(),\n  2023→                    debugArtifact,\n  2024→                    getSink(),\n  2025→                    disassemblyDebugArtifact.writeRef()));\n  2026→                disassemblyDebugArtifact->setName(debugArtifact->getName());\n  2027→\n  2028→                // The disassembly needs both the metadata for the debug build identifier\n  2029→                // and the debug spirv to be associated with is.\n  2030→                for (auto associated : intermediateArtifact->getAssociated())\n  2031→                {\n  2032→                    if (associated->getDesc().payload == ArtifactPayload::Metadata ||\n  2033→                        associated->getDesc().payload == ArtifactPayload::PostEmitMetadata)\n  2034→                    {\n  2035→                        disassemblyArtifact->addAssociated(associated);\n  2036→                        break;\n  2037→                    }\n  2038→                }\n  2039→                disassemblyArtifact->addAssociated(disassemblyDebugArtifact);\n  2040→            }\n  2041→\n  2042→            outArtifact.swap(disassemblyArtifact);\n  2043→            return SLANG_OK;\n  2044→        }\n  2045→    case CodeGenTarget::SPIRV:\n  2046→        if (getTargetProgram()->getOptionSet().shouldEmitSPIRVDirectly())\n  2047→        {\n  2048→            SLANG_RETURN_ON_FAIL(emitSPIRVForEntryPointsDirectly(this, outArtifact));\n  2049→            return SLANG_OK;\n  2050→        }\n  2051→        [[fallthrough]];\n  2052→    case CodeGenTarget::DXIL:\n  2053→    case CodeGenTarget::DXBytecode:\n  2054→    case CodeGenTarget::MetalLib:\n  2055→    case CodeGenTarget::PTX:\n  2056→    case CodeGenTarget::ShaderHostCallable:\n  2057→    case CodeGenTarget::ShaderSharedLibrary:\n  2058→    case CodeGenTarget::HostExecutable:\n  2059→    case CodeGenTarget::HostHostCallable:\n  2060→    case CodeGenTarget::HostSharedLibrary:\n  2061→    case CodeGenTarget::WGSLSPIRV:\n  2062→        SLANG_RETURN_ON_FAIL(emitWithDownstreamForEntryPoints(outArtifact));\n  2063→        return SLANG_OK;\n  2064→    case CodeGenTarget::HostVM:\n  2065→        SLANG_RETURN_ON_FAIL(emitHostVMCode(this, outArtifact));\n  2066→        return SLANG_OK;\n  2067→    default:\n  2068→        break;\n  2069→    }\n  2070→\n  2071→    return SLANG_FAIL;\n  2072→}\n  2073→\n  2074→// Helper class for recording compile time.\n  2075→struct CompileTimerRAII\n  2076→{\n  2077→    std::chrono::high_resolution_clock::time_point startTime;\n  2078→    Session* session;\n  2079→    CompileTimerRAII(Session* inSession)\n  2080→    {\n  2081→        startTime = std::chrono::high_resolution_clock::now();\n  2082→        session = inSession;\n  2083→    }\n  2084→    ~CompileTimerRAII()\n  2085→    {\n  2086→        double elapsedTime = std::chrono::duration_cast<std::chrono::microseconds>(\n  2087→                                 std::chrono::high_resolution_clock::now() - startTime)\n  2088→                                 .count() /\n  2089→                             1e6;\n  2090→        session->addTotalCompileTime(elapsedTime);\n  2091→    }\n  2092→};\n  2093→\n  2094→// Do emit logic for a zero or more entry points\n  2095→SlangResult CodeGenContext::emitEntryPoints(ComPtr<IArtifact>& outArtifact)\n  2096→{\n  2097→    CompileTimerRAII recordCompileTime(getSession());\n  2098→\n  2099→    auto target = getTargetFormat();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01LHB7gGBJfPdzXX99Db2wbv","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"I can see that there's a good example at line 2078 where there's a local variable named `Session* session` and at line 2090 it's used as `session->addTotalCompileTime(elapsedTime);`. This looks like a good candidate for renaming from `session` to `globalSession`.\n\nLet me start the systematic renaming process. I'll begin by creating the TodoWrite to track my progress and break down the tasks more specifically:\n\n1. First, rename the class definition itself\n2. Then systematically go through files and rename references\n3. Look for variables that should be renamed\n4. Look for methods that should be renamed\n\nLet me start by finding the header file where Session is defined and change the class name.","signature":"EusGCkgIBRABGAIqQENgN7ulvuyKBK7yk1XFZ9TgbL1JVRbOFIos+F1s31kvU4iTEcwS2qUg2Bv0WwBWersSqBBBV2xH7IMmgHdlg+ESDHn5a0FFKt4iYVR5uhoMp8Crz2BUmTjTb59PIjDpAr3QxJIGrJLOSl2ocAivUnkqoPu5kH2bUYuQgsMOMk3Ng+z3lxfHmBXWGltQmDAq0AXRI1zKjxQ+G5Qifd+SFRg4DdaPSoxNh7Oeq0ZLJcjRBT/k9WLirwUggiaJOILUUkkE92mhwgRAqkP7Qyt74VTPO+EQdNhwlqzlexN7WnjAfWCj0+v0OB7IRP6zH9OCIbwmsnK5BX8y5GqRVhGYEC9ZqqqmWFDcDTwbsncI6gZnpakNx8s2sZUOg7QAGhZRFMmtVBXxUy6MEXHbn27ARiRErBTwBUV5OfPUu8xgajFloNJabZzYyi4qEoXVNA/lRZOP2CCsBkZdJzCsnVPoIqLlaof44lQ0zCZOOom+spyh8LGZXm2xz+p4j+rq2ChnxIGwsLOmtLI/hkXu1WvbelLoO6y7Tj1pTnOo0msDtzkNAAOrzDJEERcJOseecHmw471sCcykkzPCQrnalf1eV2wZIoOUBJiZ9p84klGf8TFFxYfVeGdpPtXmjJSPnP88OgvDHVFmB/NzkWbrrDN6yzBqoNDRZSWRJ7oSPLEugWqGVaOFT31pjPSn/vupW9fA86Te48QZKKvlpSrEU0PykIpKph6sVLX5sbx6VDu196ONmw+rXE5TEP8dVf4obUbW5MBaLCGE04bAPGHdPwMClqyq8beAdeqEnTOkPkbJ+NRHxx88Fel3KMbbdzMIYggJPx6msdI7OZ1rVZQf7L6WtvvL//hhQg5J4bEjO0E3Jurb0AboDmalDtmI38stmDAq9DLEeP6zUoXXYtqYk+4Ip+6JSD6TGFWpDoLT+askANJ2bxNBI3mW0y/bhTOcJvkQZ+FDPXXlILKpbg+bWoIyeravsXfRcU9gppdqEGNgsYhTE+3ZrVB1tZqrtGll7k+wCnr4+jNueKRJn6Ekiz5UqjFkPR6kYL78i83pbbcD4z6uS+L99VD6z9pLyaEvRpWTWknSM+Y10LknGN8TckVw1EoyTnZW13d9CRQxfsbbtRLfHuz1aJ6ysmDxQIohzQ5gDsAYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":3294,"cache_read_input_tokens":94696,"output_tokens":3}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01LHB7gGBJfPdzXX99Db2wbv","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01S5YuhMWa1SxibSz8fePTFA","name":"mcp__github_comment__update_claude_comment","input":{"body":"Working on implementing the `Slang::Session` → `Slang::GlobalSession` renaming <img src=\"https://github.com/user-attachments/assets/5ac382c7-e004-429b-8e35-7feb3e8f9c6f\" width=\"14px\" height=\"14px\" style=\"vertical-align: middle; margin-left: 4px;\" />\n\n### Task List\n- [x] Analyze codebase structure and find all `Slang::Session` references\n- [ ] Rename the class `Slang::Session` to `Slang::GlobalSession` in header files\n- [ ] Update all references to the class name in implementation files  \n- [ ] Rename variables from `session` to `globalSession` where appropriate\n- [ ] Rename accessor methods from `getSession()` to `getGlobalSession()` etc.\n- [ ] Update comments and documentation\n- [ ] Verify build still works\n- [ ] Run formatting script\n- [ ] Commit and push changes\n- [ ] Create PR link\n\nI found the main class definition at line 2622 in `/home/runner/work/slang/slang/source/slang/slang-compiler.h`:\n\n```cpp\nclass Session : public RefObject, public slang::IGlobalSession\n```\n\nThis appears to be the implementation of the `slang::IGlobalSession` public API interface. I also found 60 files that reference `Slang::Session`, and 59 files with `getSession()` methods that may need renaming.\n\n### Analysis Summary:\n- **Class definition**: `/home/runner/work/slang/slang/source/slang/slang-compiler.h:2622`\n- **Variables needing renaming**: Found patterns like `Session* session` that should become `Session* globalSession`\n- **Method calls**: 59 files have `getSession()` methods that should become `getGlobalSession()`\n- **References**: 60 files reference `Slang::Session` that need updating\n\n---\n[View job run](https://github.com/shader-slang/slang/actions/runs/16329805070)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":3294,"cache_read_input_tokens":94696,"output_tokens":732}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01S5YuhMWa1SxibSz8fePTFA","type":"tool_result","content":[{"type":"text","text":"{\n  \"id\": 3080606462,\n  \"html_url\": \"https://github.com/shader-slang/slang/issues/7793#issuecomment-3080606462\",\n  \"updated_at\": \"2025-07-16T21:03:14Z\"\n}"}]}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_015tTFFHw7ao5zgRwAiwnQFg","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Now let me start with the systematic renaming. I'll begin by changing the class definition in the header file.","signature":"EpsCCkgIBRABGAIqQGLXSJ/SJRnmMXAd67rcKEMm8Qu03f6AKey1az2c7k/YoG0EjN9jFCBL11XM10hW7aTQlw7bRnS733S+X2qtn98SDIcL1ZQKrFbUWMnPoBoMG1wCFvcEOUUquwroIjDG5kZBKbqCy8n5fLU9Ny5V6dywWaYEQ4v8ATPaTV7CM4P1ASHtiPiM4YgFVsB0ZDsqgAFh/2elBKwSyJ9GPdjZ4zKObX71iQc1/D2Che22ADWr7Sa6l+7GnfPwiYaCNSLewIYkcGYWIxjtFCdlWLbMaDCor5/M9g54+fabrlptQxUl3ZsUuoakzQ2s8C9gYCRQIzhJ6hlZNPwEdAMuO2YM1QTuqirnwCkJoWbPKaaqFyVW/RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":822,"cache_read_input_tokens":97990,"output_tokens":2}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_015tTFFHw7ao5zgRwAiwnQFg","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01XiMSRg3wJvEnhzhF1vtY4t","name":"Edit","input":{"file_path":"/home/runner/work/slang/slang/source/slang/slang-compiler.h","old_string":"class Session : public RefObject, public slang::IGlobalSession","new_string":"class GlobalSession : public RefObject, public slang::IGlobalSession"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":822,"cache_read_input_tokens":97990,"output_tokens":173}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01XiMSRg3wJvEnhzhF1vtY4t","type":"tool_result","content":"The file /home/runner/work/slang/slang/source/slang/slang-compiler.h has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  3618→protected:\n  3619→    Dictionary<Pair, PassThroughMode> m_map;\n  3620→};\n  3621→\n  3622→class GlobalSession : public RefObject, public slang::IGlobalSession\n  3623→{\n  3624→public:\n  3625→    SLANG_COM_INTERFACE(\n  3626→        0xd6b767eb,"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01AcqWRK7tSQv58LFi62Ety6","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Good! Now I need to find and update all references to the class. Let me look for other references in this same header file first.","signature":"Eq8CCkgIBRABGAIqQK8131yn3J/Q8dtQfDgYJedK7gBNnjwgkTWey6WRcVLVeGixZAsvZfKUETAd0ydgXZtc7HCCUBD1sEKQSBccwIMSDGXy9gRJvL7fpsHDVBoMCUTIkTaaPeS0zXqVIjBO2ZXdzueMEBf73kZ4bfVJune65QvazT4NzP+0dd2CZ34AipgnkM4LlwBlpeUZH9QqlAHlHlIKFizUdhPJdMONhs4I5Rny5zqu6FVxvuKTRRayaNaD2xK9CP41p63IbzXoWkGgPooHtVcYG8+C7T234LVEQLpdTO+UDPel04pOceyFzB9np0zRkveI7WfFl1effvW9Q283N4W8aGe6YVRndtzMV3M1XShI3N1Va55z1GbGdLqI5hDe15XCSnXe1UowKrT+dtM0GAE="}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":341,"cache_read_input_tokens":98812,"output_tokens":109}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01AcqWRK7tSQv58LFi62Ety6","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01YEAbeyB79zNuKrAnzjBSbX","name":"Grep","input":{"pattern":"Session\\*","include":"*.h"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":341,"cache_read_input_tokens":98812,"output_tokens":109}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01YEAbeyB79zNuKrAnzjBSbX","type":"tool_result","content":"Found 68 files\n/home/runner/work/slang/slang/source/slang/slang-compiler.h\n/home/runner/work/slang/slang/external/slang-rhi/tests/testing.h\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/wgpu/wgpu-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/shader-object.h\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/debug-layer/debug-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d12/d3d12-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cuda/cuda-device.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-shader-object-layout.h\n/home/runner/work/slang/slang/external/slang-rhi/src/cpu/cpu-device.h\n/home/runner/work/slang/slang/external/slang-rhi/include/slang-rhi.h\n/home/runner/work/slang/slang/tools/unit-test/slang-unit-test.h\n/home/runner/work/slang/slang/tools/slang-test/slangc-tool.h\n/home/runner/work/slang/slang/tools/slang-test/slangi-tool-impl.h\n/home/runner/work/slang/slang/tools/slang-test/slangi-tool.h\n/home/runner/work/slang/slang/tools/slang-test/test-context.h\n/home/runner/work/slang/slang/tools/render-test/slang-support.h\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/vulkan/vk-device.h\n/home/runner/work/slang/slang/tools/gfx/renderer-shared.h\n/home/runner/work/slang/slang/tools/gfx/metal/metal-device.h\n/home/runner/work/slang/slang/tools/gfx/metal/metal-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/debug-layer/debug-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/d3d12/d3d12-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-device.h\n/home/runner/work/slang/slang/tools/gfx/d3d11/d3d11-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx/cuda/cuda-device.h\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-device.h\n/home/runner/work/slang/slang/tools/gfx/cpu/cpu-shader-object-layout.h\n/home/runner/work/slang/slang/tools/gfx-unit-test/gfx-test-util.h\n/home/runner/work/slang/slang/source/slang/slang-workspace-version.h\n/home/runner/work/slang/slang/source/slang/slang-serialize-container.h\n/home/runner/work/slang/slang/source/slang/slang-serialize-ir.h\n/home/runner/work/slang/slang/source/slang/slang-language-server.h\n/home/runner/work/slang/slang/source/slang/slang-legalize-types.h\n/home/runner/work/slang/slang/source/slang/slang-ir.h\n/home/runner/work/slang/slang/source/slang/slang-ir-insts.h\n/home/runner/work/slang/slang/source/slang/slang-ir-glsl-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-ir-byte-address-legalize.h\n/home/runner/work/slang/slang/source/slang/slang-internal.h\n/home/runner/work/slang/slang/source/slang/slang-emit-c-like.h\n/home/runner/work/slang/slang/source/slang/slang-compiler-options.h\n/home/runner/work/slang/slang/source/slang/slang-check.h\n/home/runner/work/slang/slang/source/slang/slang-check-impl.h\n/home/runner/work/slang/slang/source/slang/slang-ast-builder.h\n/home/runner/work/slang/slang/source/slang/slang-artifact-output-util.h\n/home/runner/work/slang/slang/source/slang-wasm/slang-wasm.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-entrypoint.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-global-session.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-module.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-session.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-type-conformance.h\n/home/runner/work/slang/slang/source/slang-record-replay/record/slang-component-type.h\n/home/runner/work/slang/slang/source/core/slang-test-tool-util.h\n/home/runner/work/slang/slang/include/slang.h\n/home/runner/work/slang/slang/include/slang-deprecated.h\n/home/runner/work/slang/slang/include/slang-gfx.h"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01R2GcTdK2FYVwTptjCYkads","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me look at the main compiler header to see what other references need updating there.\n","signature":"EocCCkgIBRABGAIqQOczAjZlrrIoazZQzJK5VZpPYeeflut3otkoJXDMxOcILaiUuN8BI0yhELV1PUPbjz3pd7Rx8WfUrbfpIKTVckMSDJ+qDffrB13emLlYzxoMReMFL4LUx9Pti6vpIjBfJtRXBuoqe5VlaULPa/DsRGHzpic2bHcKEH5e3Obn8jWCKQ+sscx8oE05ZJw6OYkqbaReDHsS7am4yK50EfN6Hq6wR32w2uwVl2P8rcgTPMym9EotrWgw2jrAAQjzG/Ccyhe/Ew397LbVHqSc/V9kGOVP5pmkNF7vYfEET+/NoBtdA9RFFH1fYYGHWrCfS19CF9Cax1V2xYsANaBvXycYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":5131,"cache_read_input_tokens":96212,"output_tokens":118}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01R2GcTdK2FYVwTptjCYkads","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_015UmuFXnz361yYLTbouB93C","name":"Grep","input":{"pattern":"Session","path":"/home/runner/work/slang/slang/source/slang/slang-compiler.h"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":5131,"cache_read_input_tokens":96212,"output_tokens":118}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_015UmuFXnz361yYLTbouB93C","type":"tool_result","content":"Found 1 file\n/home/runner/work/slang/slang/source/slang/slang-compiler.h"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_015gK3RKewUSC6SPNwdfgv2d","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me see the specific instances of Session in that header file.\n","signature":"Eu4BCkgIBRABGAIqQHHAGzT4c7nZwwx0AbYyAXt6pV73t40KxBBLH4DFlWlE6ahZ7IjMkQmMOF8jzgg2mgKYro4v52u4zO0aFRsXtR4SDGrAaCUhwkyRHxEV2xoMn7C1IO+PIa/Psac6IjC6d1DOJDxmNe7FfYn5v6RAmXGUAyJQjo1fDBjFmVrinE1ibwbkMa24FU8aKsgwXKIqVDXzVFlwXRtOQQw7GQUihvplgqVwtsZ9IyGhC0fpo3VROyJB6HJ3IScvMqGhxVHhyPCRGPsPW/pfCQ8/mkpVni2DNqSKe/8qOJ4PUEdcrBiCApvm9xgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2356,"cache_read_input_tokens":99153,"output_tokens":6}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_015gK3RKewUSC6SPNwdfgv2d","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01ME6nwJqtNwjyv31fdmpuqw","name":"Bash","input":{"command":"rg \"Session\" /home/runner/work/slang/slang/source/slang/slang-compiler.h -n","description":"Search for Session references in compiler header"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2356,"cache_read_input_tokens":99153,"output_tokens":127}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01ME6nwJqtNwjyv31fdmpuqw","type":"tool_result","content":"303:    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE;\n797:    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n799:        return Super::getSession();\n942:    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n944:        return Super::getSession();\n1242:    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n1244:        return Super::getSession();\n1471:    SLANG_NO_THROW slang::ISession* SLANG_MCALL getSession() SLANG_OVERRIDE\n1473:        return Super::getSession();\n2000:    Session* getSession();\n2093:    Session* getSession();\n2231:class Linkage : public RefObject, public slang::ISession\n2240:    SLANG_NO_THROW slang::IGlobalSession* SLANG_MCALL getGlobalSession() override;\n2327:    Linkage(Session* session, ASTBuilder* astBuilder, Linkage* builtinLinkage);\n2338:    Session* getSessionImpl() { return m_session; }\n2564:    void _stopRetainingParentSession() { m_retainedSession = nullptr; }\n2571:    Session* m_session = nullptr;\n2573:    RefPtr<Session> m_retainedSession;\n2637:    Session* getSession();\n3055:    Session* getSession() { return getLinkage()->getSessionImpl(); }\n3320:    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSession(slang::ISession** outSession)\n3355:    EndToEndCompileRequest(Session* session);\n3462:    Session* getSession() { return m_session; }\n3516:    Session* m_session = nullptr;\n3530:SlangResult checkExternalCompilerSupport(Session* session, PassThroughMode passThrough);\n3622:class GlobalSession : public RefObject, public slang::IGlobalSession\n3636:    // slang::IGlobalSession\n3638:    createSession(slang::SessionDesc const& desc, slang::ISession** outSession) override;\n3712:        slang::SessionDesc* outSessionDesc,\n3716:    getSessionDescDigest(slang::SessionDesc* sessionDesc, ISlangBlob** outBlob) override;\n3721:    // This needs to be atomic not because of contention between threads as `Session` is\n3818:    ~Session();\n3911:SLANG_FORCE_INLINE slang::IGlobalSession* asExternal(Session* session)\n3913:    return static_cast<slang::IGlobalSession*>(session);\n3916:SLANG_FORCE_INLINE ComPtr<Session> asInternal(slang::IGlobalSession* session)\n3918:    Slang::Session* internalSession = nullptr;\n3919:    session->queryInterface(SLANG_IID_PPV_ARGS(&internalSession));\n3920:    return ComPtr<Session>(INIT_ATTACH, static_cast<Session*>(internalSession));\n3923:SLANG_FORCE_INLINE slang::ISession* asExternal(Linkage* linkage)\n3925:    return static_cast<slang::ISession*>(linkage);","is_error":false}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01PFmSJyTM9eK9j5jTRi4p7x","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"I need to be careful here. I can see that there are several different types of references:\n\n1. `class GlobalSession` - this I already renamed\n2. `Session*` - references to the class that need to become `GlobalSession*`\n3. `slang::ISession` - these are the public API interface, which should NOT be changed\n4. Comments that mention Session - these need to be updated\n\nLet me focus on the actual class references that need to be changed. Looking at the output:\n\n- Line 2000: `Session* getSession();` - this should become `GlobalSession* getSession();`\n- Line 2093: `Session* getSession();` - this should become `GlobalSession* getSession();` \n- Line 2327: `Linkage(Session* session, ASTBuilder* astBuilder, Linkage* builtinLinkage);` - this should become `Linkage(GlobalSession* session, ASTBuilder* astBuilder, Linkage* builtinLinkage);`\n- Line 2338: `Session* getSessionImpl() { return m_session; }` - this should become `GlobalSession* getSessionImpl() { return m_session; }`\n- Line 2571: `Session* m_session = nullptr;` - this should become `GlobalSession* m_session = nullptr;`\n- Line 2573: `RefPtr<Session> m_retainedSession;` - this should become `RefPtr<GlobalSession> m_retainedSession;`\n- Line 2637: `Session* getSession();` - this should become `GlobalSession* getSession();`\n- Line 3055: `Session* getSession() { return getLinkage()->getSessionImpl(); }` - this should become `GlobalSession* getSession() { return getLinkage()->getSessionImpl(); }`\n- Line 3355: `EndToEndCompileRequest(Session* session);` - this should become `EndToEndCompileRequest(GlobalSession* session);`\n\n\n- Line 3462: `Session* getSession() { return m_session; }` - this should become `GlobalSession* getSession() { return m_session; }`\n- Line 3516: `Session* m_session = nullptr;` - this should become `GlobalSession* m_session = nullptr;`\n- Line 3530: `SlangResult checkExternalCompilerSupport(Session* session, PassThroughMode passThrough);` - this should become `SlangResult checkExternalCompilerSupport(GlobalSession* session, PassThroughMode passThrough);`\n\nI'm continuing to systematically replace `Session*` with `GlobalSession*` across various method signatures and member variables. The goal is to ensure consistent type usage throughout the codebase.","signature":"EqMSCkgIBRABGAIqQGARnDJ9wXucY1bHqiF83vHU2ks36V8SoLRvpXZl1Vxlo4oz/ow3ZTKRx+yaaK1VtXHuAKqmHo4lcS5jC8bXoPESDAtl66+0cAJb1KwHmhoM/DBWUiOWboFYpkXOIjB8evp1xbWqugcOzJkn9ozl45qp6D2YiJeKWH3S7vdVEvyt5DDoPnSsRfXY68Ne1d0qiBHYp+y+Bp9EnuC1VTc+05Y4GR19E79iWcIUolRf7oql5Dn/Btfpo3Jg0kyXX52jbM+UoXpCOLndEs70jCBcrMZVNxUXbQxJypjJz4H4fuCAUilG1t3wY3ZNpW6E4Xn6IGDZF+wtdHEkMuwO7fB/s8fNddKWSow18Y3o4AxcMX4OwwcMmCIGWIAbDpz9Lib1nNkvokOWwbhfe5hhowe8q2F4jr2gW7/MeGXfG6DVnZB+OfFBr9J4f+4hmD2HjI+/0aQEukKgJ3eg+/+lGQzc7/NA1ITCD31wY4+W5Tnvm6PzC9JakM9gHNtZPeM7A4KHH25S3jh35maUmuaCSCVL3b5TtzLi2GHYqQCT15zSE8jm7MyCNTipO+l9Z3+uJtLQ16qluaPGQXPG9IgE9ntSskfGXmWaSQjhQDdyH1mCu5BTOXeW6qsi/lcu0U+gcpB9WBSteYBP/T6QAo0DAkLbwnv1EiMSu38l/p1SgYgJhxFqk0O1WhThsW8Y9L4IHtJ0iwtxbc8yxqgNedYRyxbWzz81zXy6eR2YV7DzAbC2AIhOKNxea+JTypXhEnzvXTISmKj5QTV1v3aZ4vrjiIcim8RlNb9/vVoGyY1hAXlbEbcxffVIXW70yb6CBMlqMOR0cbQgAuAP73yMpQyDAfKyKIzi5mFqQgXv8pySFri8LA140FToRYqieezjflib5aT3uI3NU3IMECMjX/a8LIUS83Hull9XiPHYmQAxDuppTjjqjixqmXerfRPSLrUqKbIrwYSqWereXB/mi5D0xhZemu+bavSPoTYmJEz9XWhCOkS5kpsFK+OxdoygvszdcWnIZlXzKFpl6IECzmTMng/zdNNMc5m4iVotOXwSRBa3QNKdQRqjkUhdeUWd4bEteBn/5AEb30mGAlDL+CfdDCV7V7tBL3PzADuze5eytbJtWtpugLr81R4dJfuM1TbS5ZZRYRbwK4beCmUYCKvbLKONxUTjr+1JugomMRxQP2X9iK9HMDJoo5st0NNuDZioxo1zk+fBNvcwzf/WoX7mRrgt4awiggqAuuIajsL79s9wSEZpCfLb3C4wuqXNNFP82sAVyk/rsZVE3yq5lo5iJtUtxkiPDug7qn4L/o9KRNHd14igZdAp46+7HiPWGzB7lPbAB7c1dMlDY5DKqn93iGDmnG9n67OFqm5WRO2gJiYntnM8O5EO7trbTX3mpd+ePNYjrLJzacoO7rO6omoXgbUPXqGw6mT59xeOEZT1rFrMnjLPqWAyeqQ3mXx+ihuTuIx/l+mbwMshMAeVtV4owq633wQZi3Z9niVftdQOkkvsGarbc4jARjzn0/CIsGA/cnQQWvX9a+VoifG+ccv6E2FavlUrzx9vO3GC/3wtqk2lEDvzm6G5VZD5pWZiBlQY79JL/tV9QVpj9E2fHFJISUqj+p8/rpSbL92V3O4cRrb4H1pp3nMbCQOp3IYYa+SHwLxJ2TiVvv5WUc/UUxsp3jxQAtyDcnLkM91nE62IUlTgIAlIasp8ySGDifcbpI0NMpO4Qde1kJ2FU0UXebbNcJ+8v9sfel1HEJdfiHMhWudlEBECqVwQa5eBg6SXo38UPubdJq1T77VA/W816V1mLusahHJiYW2Rdu/mVNhdYEGF39qb7Jfsy4ERedJL2wedc/bxtvtGf2a+XfVwfTGYAwqutpyKSuXFhbZEwFKdjixamVz/6+o58APm6k4ItA5PpNN1rm0ovRn4RQul5QSOiR09HmhrK7kXbJbd6G6ye4SsxTgTYq65iE5sjaPGrB8AoSObpPOzJq+qA/iXVS5JXt/EWfzLVE5+TQPGPlMtmc/3bnRx+O3dIobgNbBwQKxzccIxulbYjmtUxKl51Q1paHfO1e7u6eJma8uWeQbjrhy9zs9xi8FprEm4gtE5tCNbsRBgTyn1+bazlspvhetOG3YcevRYldzI39NtzRqthzXJgSr+813s+BFpPbN6w7LFXxOjtwzhZnRAOKGAKkCgDgJCll5HWUiL9xDqi3ETnajMaL/sQWdBc9huz+Qth6yWCmU/cJSjNvG1WX5jq7V/77WpsT1m7AorsPZtzrrClyrT+qB9+1BGr4/SqnZY4tnhWGi4O4UV+Q9QETfF0WV/pPh+9VWWkqFUijh2stfjho5gqFsoy8n+f4a9wzaD+Ge0l4EcHL/UyUac/v5+HZjL0cfG1pBNFCQQh4uIQtwmEktU5Ze1kctHRQWkkR7V1cBhjbpVwSXgp5uLNH404FzwUABUx/qgMLsF0T5Mdrl0X/vX0tGRIjQ5lBm8rCoQRgJmDvA+Z93QtLZwCg9U4VlZu6OhSB0/dYDbCalaGQOO7lAjT/TlTayfRZVMi/Y1jbKpjUqDYlrfz814Kg8659GPjG7DIsY7wfsNtI6Gk0xghDz32oAZFreD6po64OAwS2w74Gzlfm10mZLAEnWIEa/n9CumAquD1sVhI02JcvxLOXpxZcN0IixEMf8HsyGm7Erz65+83S4Fw1EAZ6Z1KVYMUtlJDN8LtvwiGz6Z6ZiqVWUEnKR74sU5XTUXso9b+7GjXpcrQeMrlk+UQcGVeGfjemcadxFbJrzOja4QNAkyR0NzNjMgWPgdZtLJEj+iYkEWlpOK7BIY1BdGZFor8/c2MqIg3JpgG1vXK8RbJqCPDaR/Q+PoWxdm7EJ1u//D+F4HvBiaXvwbEE3EscSI10TitrfN53lOHHf+Mh76+qdjUipRwWlkyb7vxKONFTI7zLgqd0pljfJU1E5vTFPUiM7QWPOeznox0bm3RC2BOoTAUwwOeeRrKZkK23rQP0QZ8a3sozCcYUSYoRfPl0+5GTmRE3gOB0n8KRHv8lobNwHinb4NCRb1Xc9uw1YhIQTeirewkSHUbehrE8C0No+T1WmsO+R8BLFo/PNbo8IXQNwYAQ=="}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1182,"cache_read_input_tokens":101343,"output_tokens":1736}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01PFmSJyTM9eK9j5jTRi4p7x","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_018qG4WEBYfMqZc47uhDidEC","name":"MultiEdit","input":{"file_path":"/home/runner/work/slang/slang/source/slang/slang-compiler.h","edits":[{"old_string":"    Session* getSession();","new_string":"    GlobalSession* getSession();"},{"old_string":"    Linkage(Session* session, ASTBuilder* astBuilder, Linkage* builtinLinkage);","new_string":"    Linkage(GlobalSession* globalSession, ASTBuilder* astBuilder, Linkage* builtinLinkage);"},{"old_string":"    Session* getSessionImpl() { return m_session; }","new_string":"    GlobalSession* getSessionImpl() { return m_session; }"},{"old_string":"    Session* m_session = nullptr;","new_string":"    GlobalSession* m_session = nullptr;"},{"old_string":"    RefPtr<Session> m_retainedSession;","new_string":"    RefPtr<GlobalSession> m_retainedSession;"},{"old_string":"    Session* getSession() { return getLinkage()->getSessionImpl(); }","new_string":"    GlobalSession* getSession() { return getLinkage()->getSessionImpl(); }"},{"old_string":"    EndToEndCompileRequest(Session* session);","new_string":"    EndToEndCompileRequest(GlobalSession* globalSession);"},{"old_string":"    Session* getSession() { return m_session; }","new_string":"    GlobalSession* getSession() { return m_session; }"},{"old_string":"    Session* m_session = nullptr;","new_string":"    GlobalSession* m_session = nullptr;"},{"old_string":"SlangResult checkExternalCompilerSupport(Session* session, PassThroughMode passThrough);","new_string":"SlangResult checkExternalCompilerSupport(GlobalSession* globalSession, PassThroughMode passThrough);"},{"old_string":"SLANG_FORCE_INLINE slang::IGlobalSession* asExternal(Session* session)","new_string":"SLANG_FORCE_INLINE slang::IGlobalSession* asExternal(GlobalSession* globalSession)"},{"old_string":"    return static_cast<slang::IGlobalSession*>(session);","new_string":"    return static_cast<slang::IGlobalSession*>(globalSession);"},{"old_string":"SLANG_FORCE_INLINE ComPtr<Session> asInternal(slang::IGlobalSession* session)","new_string":"SLANG_FORCE_INLINE ComPtr<GlobalSession> asInternal(slang::IGlobalSession* globalSession)"},{"old_string":"    Slang::Session* internalSession = nullptr;\n    session->queryInterface(SLANG_IID_PPV_ARGS(&internalSession));\n    return ComPtr<Session>(INIT_ATTACH, static_cast<Session*>(internalSession));","new_string":"    Slang::GlobalSession* internalGlobalSession = nullptr;\n    globalSession->queryInterface(SLANG_IID_PPV_ARGS(&internalGlobalSession));\n    return ComPtr<GlobalSession>(INIT_ATTACH, static_cast<GlobalSession*>(internalGlobalSession));"},{"old_string":"    // This needs to be atomic not because of contention between threads as `Session` is","new_string":"    // This needs to be atomic not because of contention between threads as `GlobalSession` is"},{"old_string":"    ~Session();","new_string":"    ~GlobalSession();"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1182,"cache_read_input_tokens":101343,"output_tokens":1736}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Found 3 matches of the string to replace, but replace_all is false. To replace all occurrences, set replace_all to true. To replace only one occurrence, please provide more context to uniquely identify the instance.\nString:     Session* getSession();","is_error":true,"tool_use_id":"toolu_bdrk_018qG4WEBYfMqZc47uhDidEC"}]},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"assistant","message":{"id":"msg_bdrk_01GVxqogPNWteWVUPRhKrHqV","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"thinking","thinking":"Let me be more specific with the context for each occurrence to make them unique.","signature":"EvwBCkgIBRABGAIqQCmRnH4tJR39/A/sPhA02cPysLb6MZvAgPkp8uYbb6pNy/KpDkTCJI/cqS9yV4EAtSydVi3x21QxfdvecX18b0ISDFd7OoGYdAzrTbt9ghoMaYv++BWPj3U8/ybdIjBloC/yzpeeaYYkFPkBNn2qbcbyncI7XQvzGKB5YwwW6UrlNz1B/76k5gT+nsoUmgcqYji91uc4hs35SGBLRAFd98nmzVKVVE+YYI1afxLpKJlNbLzDbCE/y/CebdMDegkeei5I2VUGHc7iZ1iMl+clpXe+kgE4V7IwglE8RJzUvmMM7noJGvTXKwNpxf1VlE5CnY2+GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1673,"cache_read_input_tokens":102525,"output_tokens":4}},"parent_tool_use_id":null,"session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":873584,"duration_api_ms":892962,"num_turns":45,"result":"","session_id":"0dd116bd-59a1-4486-8b9a-21eec0657281","total_cost_usd":0.9587136,"usage":{"input_tokens":150,"cache_creation_input_tokens":174760,"cache_read_input_tokens":869262,"output_tokens":2601,"server_tool_use":{"web_search_requests":0},"service_tier":"standard"}}
